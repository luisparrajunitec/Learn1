"use strict";
/**
 * @packageDocumentation
 *
 * This file provides utility functions related to test setup, such as creating a test provider,
 * optimizing test times via snapshots, and making test accounts.
 */
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const sol_trace_1 = require("@0x/sol-trace");
const subproviders_1 = require("@0x/subproviders");
const ethers_1 = require("ethers");
const path = __importStar(require("path"));
const debug_1 = require("./debug");
const wallet_1 = require("./wallet");
const debug = debug_1.makeDebug('helpers');
/**
 * Create a test provider which uses an in-memory, in-process chain
 */
function provider() {
    const providerEngine = new sol_trace_1.Web3ProviderEngine();
    providerEngine.addProvider(new subproviders_1.FakeGasEstimateSubprovider(5 * 10 ** 6)); // Ganache does a poor job of estimating gas, so just crank it up for testing.
    if (process.env.DEBUG) {
        debug('Debugging enabled, using sol-trace module...');
        const defaultFromAddress = '';
        const artifactAdapter = new sol_trace_1.SolCompilerArtifactAdapter(path.resolve('dist/artifacts'), path.resolve('contracts'));
        const revertTraceSubprovider = new sol_trace_1.RevertTraceSubprovider(artifactAdapter, defaultFromAddress, true);
        providerEngine.addProvider(revertTraceSubprovider);
    }
    providerEngine.addProvider(new subproviders_1.GanacheSubprovider({}));
    providerEngine.start();
    return new ethers_1.ethers.providers.Web3Provider(providerEngine);
}
exports.provider = provider;
/**
 * This helper function allows us to make use of ganache snapshots,
 * which allows us to snapshot one state instance and revert back to it.
 *
 * This is used to memoize expensive setup calls typically found in beforeEach hooks when we
 * need to setup our state with contract deployments before running assertions.
 *
 * @param provider The provider that's used within the tests
 * @param cb The callback to execute that generates the state we want to snapshot
 */
function snapshot(provider, cb) {
    if (process.env.DEBUG) {
        debug('Debugging enabled, snapshot mode disabled...');
        return cb;
    }
    const d = debug.extend('memoizeDeploy');
    let hasDeployed = false;
    let snapshotId = '';
    return async () => {
        if (!hasDeployed) {
            d('executing deployment..');
            await cb();
            d('snapshotting...');
            /* eslint-disable-next-line require-atomic-updates */
            snapshotId = await provider.send('evm_snapshot', undefined);
            d('snapshot id:%s', snapshotId);
            /* eslint-disable-next-line require-atomic-updates */
            hasDeployed = true;
        }
        else {
            d('reverting to snapshot: %s', snapshotId);
            await provider.send('evm_revert', snapshotId);
            d('re-creating snapshot..');
            /* eslint-disable-next-line require-atomic-updates */
            snapshotId = await provider.send('evm_snapshot', undefined);
            d('recreated snapshot id:%s', snapshotId);
        }
    };
}
exports.snapshot = snapshot;
/**
 * Generate roles and personas for tests along with their corrolated account addresses
 */
async function users(provider) {
    const accounts = await Promise.all(Array(8)
        .fill(null)
        .map(async (_, i) => wallet_1.createFundedWallet(provider, i).then(w => w.wallet)));
    const personas = {
        Default: accounts[0],
        Neil: accounts[1],
        Ned: accounts[2],
        Nelly: accounts[3],
        Carol: accounts[4],
        Eddy: accounts[5],
    };
    const roles = {
        defaultAccount: accounts[0],
        oracleNode: accounts[1],
        oracleNode1: accounts[2],
        oracleNode2: accounts[3],
        oracleNode3: accounts[4],
        oracleNode4: accounts[5],
        stranger: accounts[6],
        consumer: accounts[7],
    };
    return { personas, roles };
}
exports.users = users;
//# sourceMappingURL=setup.js.map