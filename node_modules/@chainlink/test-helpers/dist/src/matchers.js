"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @packageDocumentation
 *
 * This file contains a number of matcher functions meant to perform common assertions for
 * ethereum based tests. Specific assertion functions targeting chainlink smart contracts live in
 * their respective contracts/<contract>.ts file.
 */
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const debug_1 = require("./debug");
const helpers_1 = require("./helpers");
const debug = debug_1.makeDebug('helpers');
/**
 * Check that two big numbers are the same value.
 *
 * @param expected The expected value to match against
 * @param actual The actual value to match against the expected value
 * @param failureMessage Failure message to display if the actual value does not match the expected value.
 */
function bigNum(expected, actual, failureMessage) {
    const msg = failureMessage ? ': ' + failureMessage : '';
    chai_1.assert(ethers_1.ethers.utils.bigNumberify(expected).eq(ethers_1.ethers.utils.bigNumberify(actual)), `BigNum (expected)${expected} is not (actual)${actual} ${msg}`);
}
exports.bigNum = bigNum;
/**
 * Check that an evm operation reverts
 *
 * @param action The asynchronous action to execute, which should cause an evm revert.
 * @param msg The failure message to display if the action __does not__ throw
 */
async function evmRevert(action, msg) {
    const d = debug.extend('assertActionThrows');
    let e = undefined;
    try {
        if (typeof action === 'function') {
            await action();
        }
        else {
            await action;
        }
    }
    catch (error) {
        e = error;
    }
    d(e);
    if (!e) {
        chai_1.assert.exists(e, 'Expected an error to be raised');
        return;
    }
    chai_1.assert(e.message, 'Expected an error to contain a message');
    const ERROR_MESSAGES = ['invalid opcode', 'revert'];
    const hasErrored = ERROR_MESSAGES.some(msg => { var _a, _b; return (_b = (_a = e) === null || _a === void 0 ? void 0 : _a.message) === null || _b === void 0 ? void 0 : _b.includes(msg); });
    if (msg) {
        expect(e.message).toMatch(msg);
    }
    chai_1.assert(hasErrored, `expected following error message to include ${ERROR_MESSAGES.join(' or ')}. Got: "${e.message}"`);
}
exports.evmRevert = evmRevert;
/**
 * Check that a contract's abi exposes the expected interface.
 *
 * @param contract The contract with the actual abi to check the expected exposed methods and getters against.
 * @param expectedPublic The expected public exposed methods and getters to match against the actual abi.
 */
function publicAbi(contract, expectedPublic) {
    const actualPublic = [];
    for (const method of contract.interface.abi) {
        if (method.type === 'function') {
            actualPublic.push(method.name);
        }
    }
    for (const method of actualPublic) {
        const index = expectedPublic.indexOf(method);
        chai_1.assert.isAtLeast(index, 0, `#${method} is NOT expected to be public`);
    }
    for (const method of expectedPublic) {
        const index = actualPublic.indexOf(method);
        chai_1.assert.isAtLeast(index, 0, `#${method} is expected to be public`);
    }
}
exports.publicAbi = publicAbi;
/**
 * Assert that an event exists
 *
 * @param receipt The contract receipt to find the event in
 * @param eventDescription A description of the event to search by
 */
function eventExists(receipt, eventDescription) {
    const event = helpers_1.findEventIn(receipt, eventDescription);
    if (!event) {
        throw Error(`Unable to find ${eventDescription.name} in transaction receipt`);
    }
}
exports.eventExists = eventExists;
//# sourceMappingURL=matchers.js.map