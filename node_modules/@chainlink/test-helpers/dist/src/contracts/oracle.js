"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @packageDocumentation
 *
 * This file provides convenience functions to interact with existing solidity contract abstraction libraries, such as
 * @truffle/contract and ethers.js specifically for our `Oracle.sol` solidity smart contract.
 */
const ethers_1 = require("ethers");
const debug_1 = require("../debug");
const helpers_1 = require("../helpers");
const debug = debug_1.makeDebug('oracle');
/**
 * Convert the javascript format of the parameters needed to call the
 * ```solidity
 *  function fulfillOracleRequest(
 *    bytes32 _requestId,
 *    uint256 _payment,
 *    address _callbackAddress,
 *    bytes4 _callbackFunctionId,
 *    uint256 _expiration,
 *    bytes32 _data
 *  )
 * ```
 * method on an Oracle.sol contract.
 *
 * @param runRequest The run request to flatten into the correct order to perform the `fulfillOracleRequest` function
 * @param response The response to fulfill the run request with, if it is an ascii string, it is converted to bytes32 string
 * @param txOpts Additional ethereum tx options
 */
function convertFufillParams(runRequest, response, txOpts = {}) {
    const d = debug.extend('fulfillOracleRequestParams');
    d('Response param: %s', response);
    const bytes32Len = 32 * 2 + 2;
    const convertedResponse = response.length < bytes32Len
        ? ethers_1.ethers.utils.formatBytes32String(response)
        : response;
    d('Converted Response param: %s', convertedResponse);
    return [
        runRequest.requestId,
        runRequest.payment,
        runRequest.callbackAddr,
        runRequest.callbackFunc,
        runRequest.expiration,
        convertedResponse,
        txOpts,
    ];
}
exports.convertFufillParams = convertFufillParams;
/**
 * Convert the javascript format of the parameters needed to call the
 * ```solidity
 *  function cancelOracleRequest(
 *    bytes32 _requestId,
 *    uint256 _payment,
 *    bytes4 _callbackFunc,
 *    uint256 _expiration
 *  )
 * ```
 * method on an Oracle.sol contract.
 *
 * @param runRequest The run request to flatten into the correct order to perform the `cancelOracleRequest` function
 * @param txOpts Additional ethereum tx options
 */
function convertCancelParams(runRequest, txOpts = {}) {
    return [
        runRequest.requestId,
        runRequest.payment,
        runRequest.callbackFunc,
        runRequest.expiration,
        txOpts,
    ];
}
exports.convertCancelParams = convertCancelParams;
/**
 * Abi encode parameters to call the `oracleRequest` method on the [Oracle.sol](../../../evm/contracts/Oracle.sol) contract.
 * ```solidity
 *  function oracleRequest(
 *    address _sender,
 *    uint256 _payment,
 *    bytes32 _specId,
 *    address _callbackAddress,
 *    bytes4 _callbackFunctionId,
 *    uint256 _nonce,
 *    uint256 _dataVersion,
 *    bytes _data
 *  )
 * ```
 *
 * @param specId The Job Specification ID
 * @param callbackAddr The callback contract address for the response
 * @param callbackFunctionId The callback function id for the response
 * @param nonce The nonce sent by the requester
 * @param data The CBOR payload of the request
 */
function encodeOracleRequest(specId, callbackAddr, callbackFunctionId, nonce, data) {
    const oracleRequestSighash = '0x40429946';
    const oracleRequestInputs = [
        { name: '_sender', type: 'address' },
        { name: '_payment', type: 'uint256' },
        { name: '_specId', type: 'bytes32' },
        { name: '_callbackAddress', type: 'address' },
        { name: '_callbackFunctionId', type: 'bytes4' },
        { name: '_nonce', type: 'uint256' },
        { name: '_dataVersion', type: 'uint256' },
        { name: '_data', type: 'bytes' },
    ];
    const encodedParams = ethers_1.ethers.utils.defaultAbiCoder.encode(oracleRequestInputs.map(i => i.type), [
        ethers_1.ethers.constants.AddressZero,
        0,
        specId,
        callbackAddr,
        callbackFunctionId,
        nonce,
        1,
        data,
    ]);
    return `${oracleRequestSighash}${helpers_1.stripHexPrefix(encodedParams)}`;
}
exports.encodeOracleRequest = encodeOracleRequest;
/**
 * Extract a javascript representation of a run request from the data
 * contained within a EVM log.
 * ```solidity
 *  event OracleRequest(
 *    bytes32 indexed specId,
 *    address requester,
 *    bytes32 requestId,
 *    uint256 payment,
 *    address callbackAddr,
 *    bytes4 callbackFunctionId,
 *    uint256 cancelExpiration,
 *    uint256 dataVersion,
 *    bytes data
 *  );
 * ```
 *
 * @param log The log to extract the run request from
 */
function decodeRunRequest(log) {
    if (!log) {
        throw Error('No logs found to decode');
    }
    const ORACLE_REQUEST_TYPES = [
        'address',
        'bytes32',
        'uint256',
        'address',
        'bytes4',
        'uint256',
        'uint256',
        'bytes',
    ];
    const [requester, requestId, payment, callbackAddress, callbackFunc, expiration, version, data,] = ethers_1.ethers.utils.defaultAbiCoder.decode(ORACLE_REQUEST_TYPES, log.data);
    return {
        specId: log.topics[1],
        requester,
        requestId: helpers_1.toHex(requestId),
        payment: helpers_1.toHex(payment),
        callbackAddr: callbackAddress,
        callbackFunc: helpers_1.toHex(callbackFunc),
        expiration: helpers_1.toHex(expiration),
        data: helpers_1.addCBORMapDelimiters(Buffer.from(helpers_1.stripHexPrefix(data), 'hex')),
        dataVersion: version.toNumber(),
        topic: log.topics[0],
    };
}
exports.decodeRunRequest = decodeRunRequest;
/**
 * Extract a javascript representation of a ConcreteChainlinked#Request event
 * from an EVM log.
 * ```solidity
 *  event Request(
 *    bytes32 id,
 *    address callbackAddress,
 *    bytes4 callbackfunctionSelector,
 *    bytes data
 *  );
 * ```
 * The request event is emitted from the `ConcreteChainlinked.sol` testing contract.
 *
 * @param log The log to decode
 */
function decodeCCRequest(log) {
    const d = debug.extend('decodeRunABI');
    d('params %o', log);
    const REQUEST_TYPES = ['bytes32', 'address', 'bytes4', 'bytes'];
    const decodedValue = ethers_1.ethers.utils.defaultAbiCoder.decode(REQUEST_TYPES, log.data);
    d('decoded value %o', decodedValue);
    return decodedValue;
}
exports.decodeCCRequest = decodeCCRequest;
//# sourceMappingURL=oracle.js.map