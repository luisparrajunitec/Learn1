"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @packageDocumentation
 *
 * This file provides convenience functions to interact with existing solidity contract abstraction libraries, such as
 * @truffle/contract and ethers.js specifically for our `Coordinator.sol` solidity smart contract.
 */
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const helpers_1 = require("../helpers");
const matchers = __importStar(require("../matchers"));
/**
 * Create a service agreement with sane testing defaults
 *
 * @param overrides Values to override service agreement defaults
 */
function serviceAgreement(overrides) {
    const agreement = {
        payment: helpers_1.bigNum('1000000000000000000'),
        expiration: helpers_1.bigNum(300),
        endAt: helpers_1.sixMonthsFromNow(),
        oracles: [],
        requestDigest: '0xbadc0de5badc0de5badc0de5badc0de5badc0de5badc0de5badc0de5badc0de5',
        aggregator: '0x3141592653589793238462643383279502884197',
        aggInitiateJobSelector: '0xd43a12f6',
        aggFulfillSelector: '0x9760168f',
        ...overrides,
    };
    return agreement;
}
exports.serviceAgreement = serviceAgreement;
/**
 * Check that all values for the struct at this SAID have default values.
 *
 * For example, when an invalid service agreement initialization request is made to a `Coordinator`, we want to make sure that
 * it did not initialize its service agreement struct to any value, hence checking for it being empty.
 *
 * @param coordinator The coordinator contract
 * @param serviceAgreementID The service agreement ID
 *
 * @throws when any of payment, expiration, endAt, requestDigest are non-empty
 */
function assertServiceAgreementEmpty(sa) {
    matchers.bigNum(sa.payment, helpers_1.bigNum(0), 'service agreement is not absent');
    matchers.bigNum(sa.expiration, helpers_1.bigNum(0), 'service agreement is not absent');
    matchers.bigNum(sa.endAt, helpers_1.bigNum(0), 'service agreement is not absent');
    chai_1.assert.equal(sa.requestDigest, '0x0000000000000000000000000000000000000000000000000000000000000000');
}
exports.assertServiceAgreementEmpty = assertServiceAgreementEmpty;
/**
 * Create parameters needed for the
 * ```solidity
 *   function initiateServiceAgreement(
 *    bytes memory _serviceAgreementData,
 *    bytes memory _oracleSignaturesData
 *  )
 * ```
 * method of the `Coordinator.sol` contract
 *
 * @param overrides Values to override the defaults for creating a service agreement
 */
async function initiateSAParams(overrides) {
    const sa = serviceAgreement(overrides);
    const signatures = await generateOracleSignatures(sa);
    return [encodeServiceAgreement(sa), encodeOracleSignatures(signatures)];
}
exports.initiateSAParams = initiateSAParams;
const SERVICE_AGREEMENT_TYPES = [
    'uint256',
    'uint256',
    'uint256',
    'address[]',
    'bytes32',
    'address',
    'bytes4',
    'bytes4',
];
/**
 * ABI encode a service agreement object
 *
 * @param sa The service agreement to encode
 */
function encodeServiceAgreement(sa) {
    return ethers_1.ethers.utils.defaultAbiCoder.encode(SERVICE_AGREEMENT_TYPES, serviceAgreementValues(sa));
}
exports.encodeServiceAgreement = encodeServiceAgreement;
/**
 * Generate the unique identifier of a service agreement by computing its
 * digest.
 *
 * @param sa The service agreement to compute the digest of
 */
function generateSAID(sa) {
    return ethers_1.ethers.utils.solidityKeccak256(SERVICE_AGREEMENT_TYPES, serviceAgreementValues(sa));
}
exports.generateSAID = generateSAID;
/**
 * ABI encode the javascript representation of OracleSignatures
 *```solidity
 *  struct OracleSignatures {
 *    uint8[] vs;
 *    bytes32[] rs;
 *    bytes32[] ss;
 *  }
 * ```
 *
 * @param os The oracle signatures to ABI encode
 */
function encodeOracleSignatures(os) {
    const ORACLE_SIGNATURES_TYPES = ['uint8[]', 'bytes32[]', 'bytes32[]'];
    const osValues = [os.vs, os.rs, os.ss];
    return ethers_1.ethers.utils.defaultAbiCoder.encode(ORACLE_SIGNATURES_TYPES, osValues);
}
exports.encodeOracleSignatures = encodeOracleSignatures;
/**
 * Abi encode the oracleRequest() method for `Coordinator.sol`
 * ```solidity
 *  function oracleRequest(
 *    address _sender,
 *    uint256 _amount,
 *    bytes32 _sAId,
 *    address _callbackAddress,
 *    bytes4 _callbackFunctionId,
 *    uint256 _nonce,
 *    uint256 _dataVersion,
 *    bytes calldata _data
 *  )
 * ```
 *
 * @param sAID The service agreement ID
 * @param callbackAddr The callback contract address for the response
 * @param callbackFunctionId The callback function id for the response
 * @param nonce The nonce sent by the requester
 * @param data The CBOR payload of the request
 */
function encodeOracleRequest(specId, to, fHash, nonce, dataBytes) {
    const oracleRequestSighash = '0x40429946';
    const oracleRequestInputs = [
        { name: '_sender', type: 'address' },
        { name: '_amount', type: 'uint256' },
        { name: '_sAId', type: 'bytes32' },
        { name: '_callbackAddress', type: 'address' },
        { name: '_callbackFunctionId', type: 'bytes4' },
        { name: '_nonce', type: 'uint256' },
        { name: '_dataVersion', type: 'uint256' },
        { name: '_data', type: 'bytes' },
    ];
    const encodedParams = ethers_1.ethers.utils.defaultAbiCoder.encode(oracleRequestInputs.map(i => i.type), [ethers_1.ethers.constants.AddressZero, 0, specId, to, fHash, nonce, 1, dataBytes]);
    return `${oracleRequestSighash}${helpers_1.stripHexPrefix(encodedParams)}`;
}
exports.encodeOracleRequest = encodeOracleRequest;
/**
 * Generates the oracle signatures on a ServiceAgreement
 *
 * @param serviceAgreement The service agreement to sign
 * @param signers The list oracles that will sign the service agreement
 */
async function generateOracleSignatures(serviceAgreement) {
    const sAID = generateSAID(serviceAgreement);
    const signatures = [];
    for (let i = 0; i < serviceAgreement.oracles.length; i++) {
        const oracle = serviceAgreement.oracles[i];
        if (!(oracle instanceof ethers_1.ethers.Wallet)) {
            throw Error('cannot generate signatures without oracle wallets');
        }
        const oracleSignature = await personalSign(sAID, oracle);
        const requestDigestAddr = recoverAddressFromSignature(sAID, oracleSignature);
        chai_1.assert.equal(oracle.address, requestDigestAddr);
        signatures.push(oracleSignature);
    }
    return combineOracleSignatures(signatures);
}
exports.generateOracleSignatures = generateOracleSignatures;
/**
 * Signs a message according to ethereum specs by first appending
 * "\x19Ethereum Signed Message:\n' + <message.length>" to the message
 *
 * @param message The message to sign - either a Buffer or a hex string
 * @param wallet The wallet of the signer
 */
async function personalSign(message, wallet) {
    if (message instanceof String && !ethers_1.utils.isHexString(message)) {
        throw Error(`The message ${message} is not a valid hex string`);
    }
    const flatSig = await wallet.signMessage(ethers_1.utils.arrayify(message));
    const splitSignature = ethers_1.utils.splitSignature(flatSig);
    function assertIsSignature(sig) {
        if (!sig.v)
            throw Error(`Could not extract v from signature`);
    }
    assertIsSignature(splitSignature);
    return splitSignature;
}
exports.personalSign = personalSign;
/**
 * Recovers the address of the signer of a message
 *
 * @param message The message that was signed
 * @param signature The signature on the message
 */
function recoverAddressFromSignature(message, signature) {
    const messageBuff = ethers_1.utils.arrayify(message);
    return ethers_1.utils.verifyMessage(messageBuff, signature);
}
exports.recoverAddressFromSignature = recoverAddressFromSignature;
/**
 * Combine v, r, and s params of multiple signatures into format expected by contracts
 *
 * @param signatures The list of signatures to combine
 */
function combineOracleSignatures(signatures) {
    return signatures.reduce((prev, { v, r, s }) => {
        prev.vs.push(v);
        prev.rs.push(r);
        prev.ss.push(s);
        return prev;
    }, { vs: [], rs: [], ss: [] });
}
exports.combineOracleSignatures = combineOracleSignatures;
function serviceAgreementValues(sa) {
    return [
        sa.payment,
        sa.expiration,
        sa.endAt,
        sa.oracles.map(o => (o instanceof ethers_1.ethers.Wallet ? o.address : o)),
        sa.requestDigest,
        sa.aggregator,
        sa.aggInitiateJobSelector,
        sa.aggFulfillSelector,
    ];
}
//# sourceMappingURL=coordinator.js.map