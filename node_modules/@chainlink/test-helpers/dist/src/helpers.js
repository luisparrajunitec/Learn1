"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @packageDocumentation
 *
 * This file provides common utility functions to perform ethereum related tasks, like
 * data format manipulation of buffers and hex strings,
 * finding, accessing logs and events,
 * and increasing test evm time.
 */
const cbor_1 = __importDefault(require("cbor"));
const chai_1 = require("chai");
const ethers_1 = require("ethers");
/**
 * Parse out an evm word (32 bytes) into an address (20 bytes) representation
 *
 * @param hex The evm word in hex string format to parse the address
 * out of.
 */
function evmWordToAddress(hex) {
    if (!hex) {
        throw Error('Input not defined');
    }
    chai_1.assert.equal(hex.slice(0, 26), '0x000000000000000000000000');
    return ethers_1.utils.getAddress(hex.slice(26));
}
exports.evmWordToAddress = evmWordToAddress;
/**
 * Convert a number value to bytes32 format
 *
 * @param num The number value to convert to bytes32 format
 */
function numToBytes32(num) {
    const hexNum = ethers_1.utils.hexlify(num);
    const strippedNum = stripHexPrefix(hexNum);
    if (strippedNum.length > 32 * 2) {
        throw Error('Cannot convert number to bytes32 format, value is greater than maximum bytes32 value');
    }
    return addHexPrefix(strippedNum.padStart(32 * 2, '0'));
}
exports.numToBytes32 = numToBytes32;
/**
 * Convert a UTF-8 string into a bytes32 hex string representation
 *
 * The inverse function of [[parseBytes32String]]
 *
 * @param args The UTF-8 string representation to convert to a bytes32 hex string representation
 */
function toBytes32String(...args) {
    return ethers_1.utils.formatBytes32String(...args);
}
exports.toBytes32String = toBytes32String;
/**
 * Convert a bytes32 formatted hex string into its UTF-8 representation
 *
 * The inverse function of [[toBytes32String]].
 *
 * @param args The bytes32 hex string representation to convert to an UTF-8 representation
 */
function parseBytes32String(...args) {
    return ethers_1.utils.parseBytes32String(...args);
}
exports.parseBytes32String = parseBytes32String;
/**
 * Converts any number, BigNumber, hex string or Arrayish to a hex string.
 *
 * @param args Value to convert to a hex string
 */
function toHex(...args) {
    return ethers_1.utils.hexlify(...args);
}
exports.toHex = toHex;
/**
 * Create a buffer from a hex string
 *
 * @param hexstr The hex string to convert to a buffer
 */
function hexToBuf(hexstr) {
    return Buffer.from(stripHexPrefix(hexstr), 'hex');
}
exports.hexToBuf = hexToBuf;
/**
 * Convert an Ether value to a wei amount
 *
 * @param args Ether value to convert to an Ether amount
 */
function toWei(...args) {
    return ethers_1.utils.parseEther(...args);
}
exports.toWei = toWei;
/**
 * Convert a value to an ethers BigNum
 *
 * @param num Value to convert to a BigNum
 */
function bigNum(num) {
    return ethers_1.utils.bigNumberify(num);
}
exports.bigNum = bigNum;
/**
 * Convert a UTF-8 string into a bytearray
 *
 * @param args The values needed to convert a string into a bytearray
 */
function toUtf8Bytes(...args) {
    return ethers_1.utils.toUtf8Bytes(...args);
}
exports.toUtf8Bytes = toUtf8Bytes;
/**
 * Turn a [x,y] coordinate into an ethereum address
 *
 * @param pubkey The x,y coordinate to turn into an ethereum address
 */
function pubkeyToAddress(pubkey) {
    // transform the value according to what ethers expects as a value
    const concatResult = `0x04${pubkey
        .map(coord => coord.toHexString())
        .join('')
        .replace(/0x/gi, '')}`;
    return ethers_1.utils.computeAddress(concatResult);
}
exports.pubkeyToAddress = pubkeyToAddress;
/**
 * A wrapper function to make generated contracts compatible with truffle test suites.
 *
 * Note that the returned contract is an instance of ethers.Contract, not a @truffle/contract, so there are slight
 * api differences, though largely the same.
 *
 * @see https://docs.ethers.io/ethers.js/html/api-contract.html
 * @param contractFactory The ethers based contract factory to interop with
 * @param address The address to supply as the signer
 */
function create(contractFactory, address) {
    const web3Instance = global.web3;
    const provider = new ethers_1.ethers.providers.Web3Provider(web3Instance.currentProvider);
    const signer = provider.getSigner(address);
    const factory = new contractFactory(signer);
    return factory;
}
exports.create = create;
/**
 * Decodes a CBOR hex string, and adds opening and closing brackets to the CBOR if they are not present.
 *
 * @param hexstr The hex string to decode
 */
function decodeDietCBOR(hexstr) {
    const buf = hexToBuf(hexstr);
    return cbor_1.default.decodeFirstSync(addCBORMapDelimiters(buf));
}
exports.decodeDietCBOR = decodeDietCBOR;
/**
 * Add a starting and closing map characters to a CBOR encoding if they are not already present.
 */
function addCBORMapDelimiters(buffer) {
    if (buffer[0] >> 5 === 5) {
        return buffer;
    }
    /**
     * This is the opening character of a CBOR map.
     * @see https://en.wikipedia.org/wiki/CBOR#CBOR_data_item_header
     */
    const startIndefiniteLengthMap = Buffer.from([0xbf]);
    /**
     * This is the closing character in a CBOR map.
     * @see https://en.wikipedia.org/wiki/CBOR#CBOR_data_item_header
     */
    const endIndefiniteLengthMap = Buffer.from([0xff]);
    return Buffer.concat([startIndefiniteLengthMap, buffer, endIndefiniteLengthMap], buffer.length + 2);
}
exports.addCBORMapDelimiters = addCBORMapDelimiters;
/**
 * Add a hex prefix to a hex string
 *
 * @param hex The hex string to prepend the hex prefix to
 */
function addHexPrefix(hex) {
    return hex.startsWith('0x') ? hex : `0x${hex}`;
}
exports.addHexPrefix = addHexPrefix;
/**
 * Strip the leading 0x hex prefix from a hex string
 *
 * @param hex The hex string to strip the leading hex prefix out of
 */
function stripHexPrefix(hex) {
    if (!ethers_1.ethers.utils.isHexString(hex)) {
        throw Error(`Expected valid hex string, got: "${hex}"`);
    }
    return hex.replace('0x', '');
}
exports.stripHexPrefix = stripHexPrefix;
/**
 * Compute the keccak256 cryptographic hash of a value, returned as a hex string.
 * (Note: often Ethereum documentation refers to this, incorrectly, as SHA3)
 *
 * @param args The data to compute the keccak256 hash of
 */
function keccak(...args) {
    return ethers_1.utils.keccak256(...args);
}
exports.keccak = keccak;
/**
 * Increase the current time within the evm to "n" seconds past the current time
 *
 * @param seconds The number of seconds to increase to the current time by
 * @param provider The ethers provider to send the time increase request to
 */
async function increaseTimeBy(seconds, provider) {
    await provider.send('evm_increaseTime', [seconds]);
}
exports.increaseTimeBy = increaseTimeBy;
/**
 * Increase the current time within the evm to 5 minutes past the current time
 *
 * @param provider The ethers provider to send the time increase request to
 */
async function increaseTime5Minutes(provider) {
    await increaseTimeBy(5 * 600, provider);
}
exports.increaseTime5Minutes = increaseTime5Minutes;
/**
 * Typecast an ethers event to its proper type, until
 * https://github.com/ethers-io/ethers.js/pull/698 is addressed
 *
 * @param event The event to typecast
 */
function eventArgs(event) {
    var _a;
    return (_a = event) === null || _a === void 0 ? void 0 : _a.args;
}
exports.eventArgs = eventArgs;
/**
 * Find an event within a transaction receipt by its event description
 *
 * @param receipt The events array to search through
 * @param eventDescription The event description to pass to check its name by
 */
function findEventIn(receipt, eventDescription) {
    var _a;
    // the first topic of a log is always the keccak-256 hash of the event signature
    const event = (_a = receipt.events) === null || _a === void 0 ? void 0 : _a.find(e => e.topics[0] === eventDescription.topic);
    return event;
}
exports.findEventIn = findEventIn;
/**
 * Calculate six months from the current date in seconds
 */
function sixMonthsFromNow() {
    return ethers_1.utils.bigNumberify(Math.round(Date.now() / 1000.0) + 6 * 30 * 24 * 60 * 60);
}
exports.sixMonthsFromNow = sixMonthsFromNow;
/**
 * Extract array of logs from a transaction
 *
 * @param tx The transaction to wait for, then extract logs from
 */
async function getLogs(tx) {
    const receipt = await tx.wait();
    if (!receipt.logs) {
        throw Error('unable to extract logs from transaction receipt');
    }
    return receipt.logs;
}
exports.getLogs = getLogs;
/**
 * Retrieve single log from transaction
 *
 * @param tx The transaction to wait for, then extract logs from
 * @param index The index of the log to retrieve
 */
async function getLog(tx, index) {
    const logs = await getLogs(tx);
    if (!logs[index]) {
        throw Error('unable to extract log from transaction receipt');
    }
    return logs[index];
}
exports.getLog = getLog;
//# sourceMappingURL=helpers.js.map