"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const test_helpers_1 = require("@chainlink/test-helpers");
const chai_1 = require("chai");
const crypto_1 = require("crypto");
const ethers_1 = require("ethers");
const generated_1 = require("../src/generated");
let personas;
const provider = test_helpers_1.setup.provider();
const linkTokenFactory = new test_helpers_1.contract.LinkTokenFactory();
const prepaidAggregatorFactory = new generated_1.PrepaidAggregatorFactory();
beforeAll(async () => {
    personas = await test_helpers_1.setup.users(provider).then(x => x.personas);
});
describe('PrepaidAggregator', () => {
    const paymentAmount = test_helpers_1.helpers.toWei('3');
    const deposit = test_helpers_1.helpers.toWei('100');
    const answer = 100;
    const minAns = 1;
    const maxAns = 1;
    const rrDelay = 0;
    const timeout = 1800;
    const decimals = 18;
    const description = 'LINK/USD';
    let aggregator;
    let link;
    let nextRound;
    let oracleAddresses;
    async function updateFutureRounds(aggregator, overrides = {}) {
        overrides = overrides || {};
        const round = {
            payment: overrides.payment || paymentAmount,
            minAnswers: overrides.minAnswers || minAns,
            maxAnswers: overrides.maxAnswers || maxAns,
            restartDelay: overrides.restartDelay || rrDelay,
            timeout: overrides.timeout || timeout,
        };
        return aggregator.updateFutureRounds(round.payment, round.minAnswers, round.maxAnswers, round.restartDelay, round.timeout);
    }
    const deployment = test_helpers_1.setup.snapshot(provider, async () => {
        link = await linkTokenFactory.connect(personas.Default).deploy();
        aggregator = await prepaidAggregatorFactory
            .connect(personas.Carol)
            .deploy(link.address, paymentAmount, timeout, decimals, ethers_1.ethers.utils.formatBytes32String(description));
        await link.transfer(aggregator.address, deposit);
        await aggregator.updateAvailableFunds();
        test_helpers_1.matchers.bigNum(deposit, await link.balanceOf(aggregator.address));
    });
    beforeEach(async () => {
        await deployment();
        nextRound = 1;
    });
    it('has a limited public interface', () => {
        test_helpers_1.matchers.publicAbi(prepaidAggregatorFactory, [
            'addOracle',
            'allocatedFunds',
            'availableFunds',
            'description',
            'getAnswer',
            'getOriginatingRoundOfAnswer',
            'getTimedOutStatus',
            'getTimestamp',
            'latestAnswer',
            'latestRound',
            'latestSubmission',
            'latestTimestamp',
            'maxAnswerCount',
            'minAnswerCount',
            'onTokenTransfer',
            'oracleCount',
            'paymentAmount',
            'decimals',
            'removeOracle',
            'reportingRound',
            'restartDelay',
            'timeout',
            'updateAnswer',
            'updateAvailableFunds',
            'updateFutureRounds',
            'withdraw',
            'withdrawFunds',
            'withdrawable',
            // Owned methods:
            'acceptOwnership',
            'owner',
            'transferOwnership',
        ]);
    });
    describe('#constructor', () => {
        it('sets the paymentAmount', async () => {
            test_helpers_1.matchers.bigNum(ethers_1.ethers.utils.bigNumberify(paymentAmount), await aggregator.paymentAmount());
        });
        it('sets the timeout', async () => {
            test_helpers_1.matchers.bigNum(ethers_1.ethers.utils.bigNumberify(timeout), await aggregator.timeout());
        });
        it('sets the decimals', async () => {
            test_helpers_1.matchers.bigNum(ethers_1.ethers.utils.bigNumberify(decimals), await aggregator.decimals());
        });
        it('sets the description', async () => {
            chai_1.assert.equal(ethers_1.ethers.utils.formatBytes32String(description), await aggregator.description());
        });
    });
    describe('#updateAnswer', () => {
        let minMax;
        beforeEach(async () => {
            oracleAddresses = [personas.Neil, personas.Ned, personas.Nelly];
            for (let i = 0; i < oracleAddresses.length; i++) {
                minMax = i + 1;
                await aggregator
                    .connect(personas.Carol)
                    .addOracle(oracleAddresses[i].address, minMax, minMax, rrDelay);
            }
        });
        it('updates the allocated and available funds counters', async () => {
            var _a, _b;
            test_helpers_1.matchers.bigNum(0, await aggregator.allocatedFunds());
            const tx = await aggregator
                .connect(personas.Neil)
                .updateAnswer(nextRound, answer);
            const receipt = await tx.wait();
            test_helpers_1.matchers.bigNum(paymentAmount, await aggregator.allocatedFunds());
            const expectedAvailable = deposit.sub(paymentAmount);
            test_helpers_1.matchers.bigNum(expectedAvailable, await aggregator.availableFunds());
            const logged = ethers_1.ethers.utils.bigNumberify((_b = (_a = receipt.logs) === null || _a === void 0 ? void 0 : _a[1].topics[1], (_b !== null && _b !== void 0 ? _b : ethers_1.ethers.utils.bigNumberify(-1))));
            test_helpers_1.matchers.bigNum(expectedAvailable, logged);
        });
        it('updates the latest submission record for the oracle', async () => {
            let latest = await aggregator.latestSubmission(personas.Neil.address);
            chai_1.assert.equal(0, latest[0].toNumber());
            chai_1.assert.equal(0, latest[1].toNumber());
            const newAnswer = 427;
            await aggregator.connect(personas.Neil).updateAnswer(nextRound, newAnswer);
            latest = await aggregator.latestSubmission(personas.Neil.address);
            chai_1.assert.equal(newAnswer, latest[0].toNumber());
            chai_1.assert.equal(nextRound, latest[1].toNumber());
        });
        describe('when the minimum oracles have not reported', () => {
            it('pays the oracles that have reported', async () => {
                test_helpers_1.matchers.bigNum(0, await aggregator.connect(personas.Neil).withdrawable());
                await aggregator.connect(personas.Neil).updateAnswer(nextRound, answer);
                test_helpers_1.matchers.bigNum(paymentAmount, await aggregator.connect(personas.Neil).withdrawable());
                test_helpers_1.matchers.bigNum(0, await aggregator.connect(personas.Ned).withdrawable());
                test_helpers_1.matchers.bigNum(0, await aggregator.connect(personas.Nelly).withdrawable());
            });
            it('does not update the answer', async () => {
                test_helpers_1.matchers.bigNum(ethers_1.ethers.constants.Zero, await aggregator.latestAnswer());
                // Not updated because of changes by the owner setting minAnswerCount to 3
                await aggregator.connect(personas.Ned).updateAnswer(nextRound, answer);
                await aggregator.connect(personas.Nelly).updateAnswer(nextRound, answer);
                test_helpers_1.matchers.bigNum(ethers_1.ethers.constants.Zero, await aggregator.latestAnswer());
            });
        });
        describe('when an oracle prematurely bumps the round', () => {
            beforeEach(async () => {
                await updateFutureRounds(aggregator, { minAnswers: 2, maxAnswers: 3 });
                await aggregator.connect(personas.Neil).updateAnswer(nextRound, answer);
            });
            it('reverts', async () => {
                await test_helpers_1.matchers.evmRevert(aggregator.updateAnswer(nextRound + 1, answer), 'Not eligible to bump round');
            });
        });
        describe('when the minimum number of oracles have reported', () => {
            beforeEach(async () => {
                await updateFutureRounds(aggregator, { minAnswers: 2, maxAnswers: 3 });
                await aggregator.connect(personas.Neil).updateAnswer(nextRound, answer);
            });
            it('updates the answer with the median', async () => {
                test_helpers_1.matchers.bigNum(0, await aggregator.latestAnswer());
                await aggregator.connect(personas.Ned).updateAnswer(nextRound, 99);
                test_helpers_1.matchers.bigNum(99, await aggregator.latestAnswer()); // ((100+99) / 2).to_i
                await aggregator.connect(personas.Nelly).updateAnswer(nextRound, 101);
                test_helpers_1.matchers.bigNum(100, await aggregator.latestAnswer());
            });
            it('updates the updated timestamp', async () => {
                const originalTimestamp = await aggregator.latestTimestamp();
                chai_1.assert.equal(0, originalTimestamp.toNumber());
                await aggregator.connect(personas.Nelly).updateAnswer(nextRound, answer);
                const currentTimestamp = await aggregator.latestTimestamp();
                chai_1.assert.isAbove(currentTimestamp.toNumber(), originalTimestamp.toNumber());
            });
            it('announces the new answer with a log event', async () => {
                var _a, _b;
                const tx = await aggregator
                    .connect(personas.Nelly)
                    .updateAnswer(nextRound, answer);
                const receipt = await tx.wait();
                const newAnswer = ethers_1.ethers.utils.bigNumberify((_b = (_a = receipt.logs) === null || _a === void 0 ? void 0 : _a[0].topics[1], (_b !== null && _b !== void 0 ? _b : ethers_1.ethers.constants.Zero)));
                chai_1.assert.equal(answer, newAnswer.toNumber());
            });
            it('does not set the timedout flag', async () => {
                chai_1.assert.isFalse(await aggregator.getTimedOutStatus(nextRound));
                await aggregator.connect(personas.Nelly).updateAnswer(nextRound, answer);
                chai_1.assert.equal(nextRound, (await aggregator.getOriginatingRoundOfAnswer(nextRound)).toNumber());
            });
        });
        describe('when an oracle submits for a round twice', () => {
            it('reverts', async () => {
                await aggregator.connect(personas.Neil).updateAnswer(nextRound, answer);
                await test_helpers_1.matchers.evmRevert(aggregator.connect(personas.Neil).updateAnswer(nextRound, answer), 'Cannot update round reports');
            });
        });
        describe('when updated after the max answers submitted', () => {
            beforeEach(async () => {
                await updateFutureRounds(aggregator);
                await aggregator.connect(personas.Neil).updateAnswer(nextRound, answer);
            });
            it('reverts', async () => {
                await test_helpers_1.matchers.evmRevert(aggregator.connect(personas.Ned).updateAnswer(nextRound, answer), 'Round not currently eligible for reporting');
            });
        });
        describe('when a new highest round number is passed in', () => {
            it('increments the answer round', async () => {
                test_helpers_1.matchers.bigNum(ethers_1.ethers.constants.Zero, await aggregator.reportingRound());
                for (const oracle of oracleAddresses) {
                    await aggregator.connect(oracle).updateAnswer(nextRound, answer);
                }
                test_helpers_1.matchers.bigNum(ethers_1.ethers.constants.One, await aggregator.reportingRound());
            });
            it('announces a new round by emitting a log', async () => {
                var _a, _b;
                const tx = await aggregator
                    .connect(personas.Neil)
                    .updateAnswer(nextRound, answer);
                const receipt = await tx.wait();
                const topics = (_b = (_a = receipt.logs) === null || _a === void 0 ? void 0 : _a[0].topics, (_b !== null && _b !== void 0 ? _b : []));
                const roundNumber = ethers_1.ethers.utils.bigNumberify(topics[1]);
                const startedBy = test_helpers_1.helpers.evmWordToAddress(topics[2]);
                test_helpers_1.matchers.bigNum(nextRound, roundNumber.toNumber());
                test_helpers_1.matchers.bigNum(startedBy, personas.Neil.address);
            });
        });
        describe('when a round is passed in higher than expected', () => {
            it('reverts', async () => {
                await test_helpers_1.matchers.evmRevert(aggregator.connect(personas.Neil).updateAnswer(nextRound + 1, answer), 'Must report on current round');
            });
        });
        describe('when called by a non-oracle', () => {
            it('reverts', async () => {
                await test_helpers_1.matchers.evmRevert(aggregator.connect(personas.Carol).updateAnswer(nextRound, answer), 'Only updatable by whitelisted oracles');
            });
        });
        describe('when there are not sufficient available funds', () => {
            beforeEach(async () => {
                await aggregator
                    .connect(personas.Carol)
                    .withdrawFunds(personas.Carol.address, deposit);
            });
            it('reverts', async () => {
                await test_helpers_1.matchers.evmRevert(aggregator.connect(personas.Neil).updateAnswer(nextRound, answer), 'SafeMath: subtraction overflow');
            });
        });
        describe('when price is updated mid-round', () => {
            const newAmount = test_helpers_1.helpers.toWei('50');
            it('pays the same amount to all oracles per round', async () => {
                test_helpers_1.matchers.bigNum(0, await aggregator.connect(personas.Neil).withdrawable());
                test_helpers_1.matchers.bigNum(0, await aggregator.connect(personas.Nelly).withdrawable());
                await aggregator.connect(personas.Neil).updateAnswer(nextRound, answer);
                await updateFutureRounds(aggregator, { payment: newAmount });
                await aggregator.connect(personas.Nelly).updateAnswer(nextRound, answer);
                test_helpers_1.matchers.bigNum(paymentAmount, await aggregator.connect(personas.Neil).withdrawable());
                test_helpers_1.matchers.bigNum(paymentAmount, await aggregator.connect(personas.Nelly).withdrawable());
            });
        });
        describe('when delay is on', () => {
            beforeEach(async () => {
                await updateFutureRounds(aggregator, {
                    minAnswers: oracleAddresses.length,
                    maxAnswers: oracleAddresses.length,
                    restartDelay: 1,
                });
            });
            it("does not revert on the oracle's first round", async () => {
                // Since lastUpdatedRound defaults to zero and that's the only
                // indication that an oracle hasn't responded, this test guards against
                // the situation where we don't check that and no one can start a round.
                await aggregator.connect(personas.Neil).updateAnswer(nextRound, answer);
            });
            it('does revert before the delay', async () => {
                await aggregator.connect(personas.Neil).updateAnswer(nextRound, answer);
                nextRound++;
                await test_helpers_1.matchers.evmRevert(aggregator.connect(personas.Neil).updateAnswer(nextRound, answer), 'Not eligible to bump round');
            });
        });
        describe('when an oracle starts a round before the restart delay is over', () => {
            beforeEach(async () => {
                await updateFutureRounds(aggregator.connect(personas.Carol));
                oracleAddresses = [personas.Neil, personas.Ned, personas.Nelly];
                for (let i = 0; i < oracleAddresses.length; i++) {
                    await aggregator
                        .connect(oracleAddresses[i])
                        .updateAnswer(nextRound, answer);
                    nextRound++;
                }
                const newDelay = 2;
                // Since Ned and Nelly have answered recently, and we set the delay
                // to 2, only Nelly can answer as she is the only oracle that hasn't
                // started the last two rounds.
                await updateFutureRounds(aggregator, {
                    maxAnswers: oracleAddresses.length,
                    restartDelay: newDelay,
                });
            });
            describe('when called by an oracle who has not answered recently', () => {
                it('does not revert', async () => {
                    await aggregator
                        .connect(personas.Neil)
                        .updateAnswer(nextRound, answer);
                });
            });
            describe('when called by an oracle who answered recently', () => {
                it('reverts', async () => {
                    await test_helpers_1.matchers.evmRevert(aggregator.connect(personas.Ned).updateAnswer(nextRound, answer), 'Round not currently eligible for reporting');
                    await test_helpers_1.matchers.evmRevert(aggregator.connect(personas.Nelly).updateAnswer(nextRound, answer), 'Round not currently eligible for reporting');
                });
            });
        });
        describe('when the price is not updated for a round', () => {
            // For a round to timeout, it needs a previous round to pull an answer
            // from, so the second round is the earliest round that can timeout,
            // pulling its answer from the first. The start of the third round is
            // the trigger that timesout the second round, so the start of the
            // third round is the earliest we can test a timeout.
            describe('on the third round or later', () => {
                beforeEach(async () => {
                    await updateFutureRounds(aggregator, {
                        minAnswers: oracleAddresses.length,
                        maxAnswers: oracleAddresses.length,
                        restartDelay: 1,
                    });
                    for (const oracle of oracleAddresses) {
                        await aggregator.connect(oracle).updateAnswer(nextRound, answer);
                    }
                    nextRound++;
                    await aggregator.connect(personas.Ned).updateAnswer(nextRound, answer);
                    await aggregator
                        .connect(personas.Nelly)
                        .updateAnswer(nextRound, answer);
                    chai_1.assert.equal(nextRound, (await aggregator.reportingRound()).toNumber());
                    await test_helpers_1.helpers.increaseTimeBy(timeout + 1, provider);
                    nextRound++;
                });
                it('allows a new round to be started', async () => {
                    await aggregator
                        .connect(personas.Nelly)
                        .updateAnswer(nextRound, answer);
                });
                it('sets the info for the previous round', async () => {
                    var _a;
                    const previousRound = nextRound - 1;
                    let updated = await aggregator.getTimestamp(previousRound);
                    let ans = await aggregator.getAnswer(previousRound);
                    chai_1.assert.equal(0, updated.toNumber());
                    chai_1.assert.equal(0, ans.toNumber());
                    const tx = await aggregator
                        .connect(personas.Nelly)
                        .updateAnswer(nextRound, answer);
                    const receipt = await tx.wait();
                    const block = await provider.getBlock((_a = receipt.blockHash, (_a !== null && _a !== void 0 ? _a : '')));
                    updated = await aggregator.getTimestamp(previousRound);
                    ans = await aggregator.getAnswer(previousRound);
                    test_helpers_1.matchers.bigNum(ethers_1.ethers.utils.bigNumberify(block.timestamp), updated);
                    chai_1.assert.equal(answer, ans.toNumber());
                });
                it('sets the previous round as timed out', async () => {
                    const previousRound = nextRound - 1;
                    chai_1.assert.isFalse(await aggregator.getTimedOutStatus(previousRound));
                    await aggregator
                        .connect(personas.Nelly)
                        .updateAnswer(nextRound, answer);
                    chai_1.assert.isTrue(await aggregator.getTimedOutStatus(previousRound));
                    chai_1.assert.equal(previousRound - 1, (await aggregator.getOriginatingRoundOfAnswer(previousRound)).toNumber());
                });
                it('still respects the delay restriction', async () => {
                    // expected to revert because the sender started the last round
                    await test_helpers_1.matchers.evmRevert(aggregator.connect(personas.Ned).updateAnswer(nextRound, answer), 'Round not currently eligible for reporting');
                });
                it('uses the timeout set at the beginning of the round', async () => {
                    await updateFutureRounds(aggregator, {
                        timeout: timeout + 100000,
                    });
                    await aggregator
                        .connect(personas.Nelly)
                        .updateAnswer(nextRound, answer);
                });
            });
            describe('earlier than the third round', () => {
                beforeEach(async () => {
                    await aggregator
                        .connect(personas.Neil)
                        .updateAnswer(nextRound, answer);
                    await aggregator
                        .connect(personas.Nelly)
                        .updateAnswer(nextRound, answer);
                    chai_1.assert.equal(nextRound, (await aggregator.reportingRound()).toNumber());
                    await test_helpers_1.helpers.increaseTimeBy(timeout + 1, provider);
                    nextRound++;
                    chai_1.assert.equal(2, nextRound);
                });
                it('does not allow a round to be started', async () => {
                    await test_helpers_1.matchers.evmRevert(aggregator.connect(personas.Nelly).updateAnswer(nextRound, answer), 'Must have a previous answer to pull from');
                });
            });
        });
    });
    describe('#getAnswer', () => {
        const answers = [1, 10, 101, 1010, 10101, 101010, 1010101];
        beforeEach(async () => {
            await aggregator
                .connect(personas.Carol)
                .addOracle(personas.Neil.address, minAns, maxAns, rrDelay);
            for (const answer of answers) {
                await aggregator.connect(personas.Neil).updateAnswer(nextRound, answer);
                nextRound++;
            }
        });
        it('retrieves the answer recorded for past rounds', async () => {
            for (let i = nextRound; i < nextRound; i++) {
                const answer = await aggregator.getAnswer(i);
                test_helpers_1.matchers.bigNum(ethers_1.ethers.utils.bigNumberify(answers[i - 1]), answer);
            }
        });
    });
    describe('#getTimestamp', () => {
        beforeEach(async () => {
            await aggregator
                .connect(personas.Carol)
                .addOracle(personas.Neil.address, minAns, maxAns, rrDelay);
            for (let i = 0; i < 10; i++) {
                await aggregator.connect(personas.Neil).updateAnswer(nextRound, i);
                nextRound++;
            }
        });
        it('retrieves the answer recorded for past rounds', async () => {
            let lastTimestamp = ethers_1.ethers.constants.Zero;
            for (let i = 1; i < nextRound; i++) {
                const currentTimestamp = await aggregator.getTimestamp(i);
                chai_1.assert.isAtLeast(currentTimestamp.toNumber(), lastTimestamp.toNumber());
                lastTimestamp = currentTimestamp;
            }
        });
    });
    describe('#addOracle', () => {
        it('increases the oracle count', async () => {
            const pastCount = await aggregator.oracleCount();
            await aggregator
                .connect(personas.Carol)
                .addOracle(personas.Neil.address, minAns, maxAns, rrDelay);
            const currentCount = await aggregator.oracleCount();
            test_helpers_1.matchers.bigNum(currentCount, pastCount + 1);
        });
        it('updates the round details', async () => {
            await aggregator
                .connect(personas.Carol)
                .addOracle(personas.Neil.address, 0, 1, 0);
            test_helpers_1.matchers.bigNum(ethers_1.ethers.constants.Zero, await aggregator.minAnswerCount());
            test_helpers_1.matchers.bigNum(ethers_1.ethers.utils.bigNumberify(1), await aggregator.maxAnswerCount());
            test_helpers_1.matchers.bigNum(ethers_1.ethers.constants.Zero, await aggregator.restartDelay());
        });
        it('emits a log', async () => {
            var _a;
            const tx = await aggregator
                .connect(personas.Carol)
                .addOracle(personas.Neil.address, minAns, maxAns, rrDelay);
            const receipt = await tx.wait();
            const added = test_helpers_1.helpers.evmWordToAddress((_a = receipt.logs) === null || _a === void 0 ? void 0 : _a[0].topics[1]);
            test_helpers_1.matchers.bigNum(added, personas.Neil.address);
        });
        describe('when the oracle has already been added', () => {
            beforeEach(async () => {
                await aggregator
                    .connect(personas.Carol)
                    .addOracle(personas.Neil.address, minAns, maxAns, rrDelay);
            });
            it('reverts', async () => {
                await test_helpers_1.matchers.evmRevert(aggregator
                    .connect(personas.Carol)
                    .addOracle(personas.Neil.address, minAns, maxAns, rrDelay), 'Address is already recorded as an oracle');
            });
        });
        describe('when called by anyone but the owner', () => {
            it('reverts', async () => {
                await test_helpers_1.matchers.evmRevert(aggregator
                    .connect(personas.Neil)
                    .addOracle(personas.Neil.address, minAns, maxAns, rrDelay), 'Only callable by owner');
            });
        });
        describe('when an oracle gets added mid-round', () => {
            beforeEach(async () => {
                oracleAddresses = [personas.Neil, personas.Ned];
                for (let i = 0; i < oracleAddresses.length; i++) {
                    await aggregator
                        .connect(personas.Carol)
                        .addOracle(oracleAddresses[i].address, i + 1, i + 1, rrDelay);
                }
                await aggregator.connect(personas.Neil).updateAnswer(nextRound, answer);
                await aggregator
                    .connect(personas.Carol)
                    .addOracle(personas.Nelly.address, 3, 3, rrDelay);
            });
            it('does not allow the oracle to update the round', async () => {
                await test_helpers_1.matchers.evmRevert(aggregator.connect(personas.Nelly).updateAnswer(nextRound, answer), 'New oracles cannot participate in in-progress rounds');
            });
            it('does allow the oracle to update future rounds', async () => {
                // complete round
                await aggregator.connect(personas.Ned).updateAnswer(nextRound, answer);
                // now can participate in new rounds
                await aggregator
                    .connect(personas.Nelly)
                    .updateAnswer(nextRound + 1, answer);
            });
        });
        describe('when an oracle is added after removed for a round', () => {
            it('allows the oracle to update', async () => {
                oracleAddresses = [personas.Neil, personas.Nelly];
                for (let i = 0; i < oracleAddresses.length; i++) {
                    await aggregator
                        .connect(personas.Carol)
                        .addOracle(oracleAddresses[i].address, i + 1, i + 1, rrDelay);
                }
                await aggregator.connect(personas.Neil).updateAnswer(nextRound, answer);
                await aggregator.connect(personas.Nelly).updateAnswer(nextRound, answer);
                nextRound++;
                await aggregator
                    .connect(personas.Carol)
                    .removeOracle(personas.Nelly.address, 1, 1, rrDelay);
                await aggregator.connect(personas.Neil).updateAnswer(nextRound, answer);
                nextRound++;
                await aggregator
                    .connect(personas.Carol)
                    .addOracle(personas.Nelly.address, 1, 1, rrDelay);
                await aggregator.connect(personas.Nelly).updateAnswer(nextRound, answer);
            });
        });
        describe('when an oracle is added and immediately removed mid-round', () => {
            it('allows the oracle to update', async () => {
                oracleAddresses = [personas.Neil, personas.Nelly];
                for (let i = 0; i < oracleAddresses.length; i++) {
                    await aggregator
                        .connect(personas.Carol)
                        .addOracle(oracleAddresses[i].address, i + 1, i + 1, rrDelay);
                }
                await aggregator.connect(personas.Neil).updateAnswer(nextRound, answer);
                await aggregator
                    .connect(personas.Carol)
                    .removeOracle(personas.Nelly.address, 1, 1, rrDelay);
                await aggregator
                    .connect(personas.Carol)
                    .addOracle(personas.Nelly.address, 1, 1, rrDelay);
                await aggregator.connect(personas.Nelly).updateAnswer(nextRound, answer);
            });
        });
        const limit = 42;
        describe(`when adding more than ${limit} oracles`, () => {
            it('reverts', async () => {
                for (let i = 0; i < limit; i++) {
                    const minMax = i + 1;
                    const fakeAddress = test_helpers_1.helpers.addHexPrefix(crypto_1.randomBytes(20).toString('hex'));
                    await aggregator
                        .connect(personas.Carol)
                        .addOracle(fakeAddress, minMax, minMax, rrDelay);
                }
                await test_helpers_1.matchers.evmRevert(aggregator
                    .connect(personas.Carol)
                    .addOracle(personas.Neil.address, limit + 1, limit + 1, rrDelay), `cannot add more than ${limit} oracles`);
            });
        });
    });
    describe('#removeOracle', () => {
        beforeEach(async () => {
            await aggregator
                .connect(personas.Carol)
                .addOracle(personas.Neil.address, minAns, maxAns, rrDelay);
            await aggregator
                .connect(personas.Carol)
                .addOracle(personas.Nelly.address, 2, 2, rrDelay, {});
        });
        it('decreases the oracle count', async () => {
            const pastCount = await aggregator.oracleCount();
            await aggregator
                .connect(personas.Carol)
                .removeOracle(personas.Neil.address, minAns, maxAns, rrDelay);
            const currentCount = await aggregator.oracleCount();
            expect(currentCount).toEqual(pastCount - 1);
        });
        it('updates the round details', async () => {
            await aggregator
                .connect(personas.Carol)
                .removeOracle(personas.Neil.address, 0, 1, 0);
            test_helpers_1.matchers.bigNum(ethers_1.ethers.constants.Zero, await aggregator.minAnswerCount());
            test_helpers_1.matchers.bigNum(ethers_1.ethers.utils.bigNumberify(1), await aggregator.maxAnswerCount());
            test_helpers_1.matchers.bigNum(ethers_1.ethers.constants.Zero, await aggregator.restartDelay());
        });
        it('emits a log', async () => {
            var _a;
            const tx = await aggregator
                .connect(personas.Carol)
                .removeOracle(personas.Neil.address, minAns, maxAns, rrDelay);
            const receipt = await tx.wait();
            const added = test_helpers_1.helpers.evmWordToAddress((_a = receipt.logs) === null || _a === void 0 ? void 0 : _a[0].topics[1]);
            test_helpers_1.matchers.bigNum(added, personas.Neil.address);
        });
        describe('when the oracle is not currently added', () => {
            beforeEach(async () => {
                await aggregator
                    .connect(personas.Carol)
                    .removeOracle(personas.Neil.address, minAns, maxAns, rrDelay);
            });
            it('reverts', async () => {
                await test_helpers_1.matchers.evmRevert(aggregator
                    .connect(personas.Carol)
                    .removeOracle(personas.Neil.address, minAns, maxAns, rrDelay), 'Address is not a whitelisted oracle');
            });
        });
        describe('when removing the last oracle', () => {
            it('does not revert', async () => {
                await aggregator
                    .connect(personas.Carol)
                    .removeOracle(personas.Neil.address, minAns, maxAns, rrDelay);
                await aggregator
                    .connect(personas.Carol)
                    .removeOracle(personas.Nelly.address, 0, 0, 0);
            });
        });
        describe('when called by anyone but the owner', () => {
            it('reverts', async () => {
                await test_helpers_1.matchers.evmRevert(aggregator
                    .connect(personas.Ned)
                    .removeOracle(personas.Neil.address, 0, 0, rrDelay), 'Only callable by owner');
            });
        });
        describe('when an oracle gets removed mid-round', () => {
            beforeEach(async () => {
                await aggregator.connect(personas.Neil).updateAnswer(nextRound, answer);
                await aggregator
                    .connect(personas.Carol)
                    .removeOracle(personas.Nelly.address, 1, 1, rrDelay);
            });
            it('is allowed to finish that round', async () => {
                await aggregator.connect(personas.Nelly).updateAnswer(nextRound, answer);
                nextRound++;
                // cannot participate in future rounds
                await test_helpers_1.matchers.evmRevert(aggregator.connect(personas.Nelly).updateAnswer(nextRound, answer), 'Oracle has been removed from whitelist');
            });
        });
    });
    describe('#withdrawFunds', () => {
        describe('when called by the owner', () => {
            it('succeeds', async () => {
                await aggregator
                    .connect(personas.Carol)
                    .withdrawFunds(personas.Carol.address, deposit);
                test_helpers_1.matchers.bigNum(0, await aggregator.availableFunds());
                test_helpers_1.matchers.bigNum(deposit, await link.balanceOf(personas.Carol.address));
            });
            it('does not let withdrawals happen multiple times', async () => {
                await aggregator
                    .connect(personas.Carol)
                    .withdrawFunds(personas.Carol.address, deposit);
                await test_helpers_1.matchers.evmRevert(aggregator
                    .connect(personas.Carol)
                    .withdrawFunds(personas.Carol.address, deposit), 'Insufficient funds');
            });
            describe('with a number higher than the available LINK balance', () => {
                beforeEach(async () => {
                    await aggregator
                        .connect(personas.Carol)
                        .addOracle(personas.Neil.address, minAns, maxAns, rrDelay);
                    await aggregator
                        .connect(personas.Neil)
                        .updateAnswer(nextRound, answer);
                });
                it('fails', async () => {
                    await test_helpers_1.matchers.evmRevert(aggregator
                        .connect(personas.Carol)
                        .withdrawFunds(personas.Carol.address, deposit), 'Insufficient funds');
                    test_helpers_1.matchers.bigNum(deposit.sub(paymentAmount), await aggregator.availableFunds());
                });
            });
        });
        describe('when called by a non-owner', () => {
            it('fails', async () => {
                await test_helpers_1.matchers.evmRevert(aggregator
                    .connect(personas.Eddy)
                    .withdrawFunds(personas.Carol.address, deposit), 'Only callable by owner');
                test_helpers_1.matchers.bigNum(deposit, await aggregator.availableFunds());
            });
        });
    });
    describe('#updateFutureRounds', () => {
        let minAnswerCount, maxAnswerCount;
        const newPaymentAmount = test_helpers_1.helpers.toWei('2');
        const newMin = 1;
        const newMax = 3;
        const newDelay = 2;
        beforeEach(async () => {
            oracleAddresses = [personas.Neil, personas.Ned, personas.Nelly];
            for (let i = 0; i < oracleAddresses.length; i++) {
                const minMax = i + 1;
                await aggregator
                    .connect(personas.Carol)
                    .addOracle(oracleAddresses[i].address, minMax, minMax, rrDelay);
            }
            minAnswerCount = oracleAddresses.length;
            maxAnswerCount = oracleAddresses.length;
            test_helpers_1.matchers.bigNum(paymentAmount, await aggregator.paymentAmount());
            chai_1.assert.equal(minAnswerCount, await aggregator.minAnswerCount());
            chai_1.assert.equal(maxAnswerCount, await aggregator.maxAnswerCount());
        });
        it('updates the min and max answer counts', async () => {
            await updateFutureRounds(aggregator, {
                payment: newPaymentAmount,
                minAnswers: newMin,
                maxAnswers: newMax,
                restartDelay: newDelay,
            });
            test_helpers_1.matchers.bigNum(newPaymentAmount, await aggregator.paymentAmount());
            test_helpers_1.matchers.bigNum(ethers_1.ethers.utils.bigNumberify(newMin), await aggregator.minAnswerCount());
            test_helpers_1.matchers.bigNum(ethers_1.ethers.utils.bigNumberify(newMax), await aggregator.maxAnswerCount());
            test_helpers_1.matchers.bigNum(ethers_1.ethers.utils.bigNumberify(newDelay), await aggregator.restartDelay());
        });
        it('emits a log announcing the new round details', async () => {
            var _a;
            const tx = await updateFutureRounds(aggregator, {
                payment: newPaymentAmount,
                minAnswers: newMin,
                maxAnswers: newMax,
                restartDelay: newDelay,
                timeout: timeout + 1,
            });
            const receipt = await tx.wait();
            const round = test_helpers_1.helpers.eventArgs((_a = receipt.events) === null || _a === void 0 ? void 0 : _a[0]);
            test_helpers_1.matchers.bigNum(newPaymentAmount, round.paymentAmount);
            chai_1.assert.equal(newMin, round.minAnswerCount);
            chai_1.assert.equal(newMax, round.maxAnswerCount);
            chai_1.assert.equal(newDelay, round.restartDelay);
            chai_1.assert.equal(timeout + 1, round.timeout);
        });
        describe('when it is set to higher than the number or oracles', () => {
            it('reverts', async () => {
                await test_helpers_1.matchers.evmRevert(updateFutureRounds(aggregator, {
                    maxAnswers: 4,
                }), 'Cannot have the answer max higher oracle count');
            });
        });
        describe('when it sets the min higher than the max', () => {
            it('reverts', async () => {
                await test_helpers_1.matchers.evmRevert(updateFutureRounds(aggregator, {
                    minAnswers: 3,
                    maxAnswers: 2,
                }), 'Cannot have the answer minimum higher the max');
            });
        });
        describe('when delay equal or greater the oracle count', () => {
            it('reverts', async () => {
                await test_helpers_1.matchers.evmRevert(updateFutureRounds(aggregator, {
                    restartDelay: 3,
                }), 'Restart delay must be less than oracle count');
            });
        });
        describe('when called by anyone but the owner', () => {
            it('reverts', async () => {
                await test_helpers_1.matchers.evmRevert(updateFutureRounds(aggregator.connect(personas.Ned)), 'Only callable by owner');
            });
        });
    });
    describe('#updateAvailableFunds', () => {
        it('checks the LINK token to see if any additional funds are available', async () => {
            const originalBalance = await aggregator.availableFunds();
            await aggregator.updateAvailableFunds();
            test_helpers_1.matchers.bigNum(originalBalance, await aggregator.availableFunds());
            await link.transfer(aggregator.address, deposit);
            await aggregator.updateAvailableFunds();
            const newBalance = await aggregator.availableFunds();
            test_helpers_1.matchers.bigNum(originalBalance.add(deposit), newBalance);
        });
        it('removes allocated funds from the available balance', async () => {
            const originalBalance = await aggregator.availableFunds();
            await aggregator
                .connect(personas.Carol)
                .addOracle(personas.Neil.address, minAns, maxAns, rrDelay);
            await aggregator.connect(personas.Neil).updateAnswer(nextRound, answer);
            await link.transfer(aggregator.address, deposit);
            await aggregator.updateAvailableFunds();
            const expected = originalBalance.add(deposit).sub(paymentAmount);
            const newBalance = await aggregator.availableFunds();
            test_helpers_1.matchers.bigNum(expected, newBalance);
        });
        it('emits a log', async () => {
            var _a, _b;
            await link.transfer(aggregator.address, deposit);
            const tx = await aggregator.updateAvailableFunds();
            const receipt = await tx.wait();
            const reportedBalance = ethers_1.ethers.utils.bigNumberify((_b = (_a = receipt.logs) === null || _a === void 0 ? void 0 : _a[0].topics[1], (_b !== null && _b !== void 0 ? _b : -1)));
            test_helpers_1.matchers.bigNum(await aggregator.availableFunds(), reportedBalance);
        });
        describe('when the available funds have not changed', () => {
            it('does not emit a log', async () => {
                var _a;
                const tx = await aggregator.updateAvailableFunds();
                const receipt = await tx.wait();
                chai_1.assert.equal(0, (_a = receipt.logs) === null || _a === void 0 ? void 0 : _a.length);
            });
        });
    });
    describe('#withdraw', () => {
        beforeEach(async () => {
            await aggregator
                .connect(personas.Carol)
                .addOracle(personas.Neil.address, minAns, maxAns, rrDelay);
            await aggregator.connect(personas.Neil).updateAnswer(nextRound, answer);
        });
        it('transfers LINK to the caller', async () => {
            const originalBalance = await link.balanceOf(aggregator.address);
            test_helpers_1.matchers.bigNum(0, await link.balanceOf(personas.Neil.address));
            await aggregator
                .connect(personas.Neil)
                .withdraw(personas.Neil.address, paymentAmount);
            test_helpers_1.matchers.bigNum(originalBalance.sub(paymentAmount), await link.balanceOf(aggregator.address));
            test_helpers_1.matchers.bigNum(paymentAmount, await link.balanceOf(personas.Neil.address));
        });
        it('decrements the allocated funds counter', async () => {
            const originalAllocation = await aggregator.allocatedFunds();
            await aggregator
                .connect(personas.Neil)
                .withdraw(personas.Neil.address, paymentAmount);
            test_helpers_1.matchers.bigNum(originalAllocation.sub(paymentAmount), await aggregator.allocatedFunds());
        });
        describe('when the caller withdraws more than they have', () => {
            it('reverts', async () => {
                await test_helpers_1.matchers.evmRevert(aggregator
                    .connect(personas.Neil)
                    .withdraw(personas.Neil.address, paymentAmount.add(ethers_1.ethers.utils.bigNumberify(1))), 'Insufficient balance');
            });
        });
    });
    describe('#onTokenTransfer', () => {
        it('updates the available balance', async () => {
            const originalBalance = await aggregator.availableFunds();
            await aggregator.updateAvailableFunds();
            test_helpers_1.matchers.bigNum(originalBalance, await aggregator.availableFunds());
            await link.transferAndCall(aggregator.address, deposit, '0x', {
                value: 0,
            });
            const newBalance = await aggregator.availableFunds();
            test_helpers_1.matchers.bigNum(originalBalance.add(deposit), newBalance);
        });
    });
});
//# sourceMappingURL=PrepaidAggregator.test.js.map