"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const test_helpers_1 = require("@chainlink/test-helpers");
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const generated_1 = require("../src/generated");
const provider = test_helpers_1.setup.provider();
const linkTokenFactory = new test_helpers_1.contract.LinkTokenFactory();
const coordinatorFactory = new generated_1.CoordinatorFactory();
const emptyAggregatorFactory = new generated_1.EmptyAggregatorFactory();
const meanAggregatorFactory = new generated_1.MeanAggregatorFactory();
const getterSetterFactory = new generated_1.GetterSetterFactory();
const maliciousRequesterFactory = new generated_1.MaliciousRequesterFactory();
const maliciousConsumerFactory = new generated_1.MaliciousConsumerFactory();
const oracleRequestEvent = coordinatorFactory.interface.events.OracleRequest;
const newServiceAgreementEvent = coordinatorFactory.interface.events.NewServiceAgreement;
let roles;
let link;
let coord;
let emptyAggregator;
let meanAggregator;
let oracle1;
let oracle2;
let oracle3;
const deployment = test_helpers_1.setup.snapshot(provider, async () => {
    link = await linkTokenFactory.connect(roles.defaultAccount).deploy();
    coord = await coordinatorFactory
        .connect(roles.defaultAccount)
        .deploy(link.address);
    emptyAggregator = await emptyAggregatorFactory
        .connect(roles.defaultAccount)
        .deploy();
    meanAggregator = await meanAggregatorFactory
        .connect(roles.defaultAccount)
        .deploy();
});
beforeAll(async () => {
    roles = await test_helpers_1.setup.users(provider).then(x => x.roles);
    oracle1 = roles.oracleNode1.address;
    oracle2 = roles.oracleNode2.address;
    oracle3 = roles.oracleNode3.address;
});
beforeEach(deployment);
describe('Coordinator', () => {
    it('has a limited public interface', () => {
        test_helpers_1.matchers.publicAbi(coordinatorFactory, [
            'EXPIRY_TIME',
            'balanceOf',
            'cancelOracleRequest',
            'depositFunds',
            'fulfillOracleRequest',
            'getId',
            'initiateServiceAgreement',
            'onTokenTransfer',
            'oracleRequest',
            'serviceAgreements',
            'withdraw',
            'withdrawableTokens',
        ]);
    });
    describe('#getId', () => {
        it('matches the ID generated by the oracle off-chain', async () => {
            const agreement = test_helpers_1.coordinator.serviceAgreement({
                payment: 1,
                expiration: 2,
                requestDigest: '0x85820c5ec619a1f517ee6cfeff545ec0ca1a90206e1a38c47f016d4137e801dd',
                aggregator: emptyAggregator.address,
            });
            const sAID = test_helpers_1.coordinator.generateSAID(agreement);
            const sAAsData = test_helpers_1.coordinator.encodeServiceAgreement(agreement);
            const result = await coord.getId(sAAsData);
            chai_1.assert.equal(result.toLowerCase(), sAID);
        });
    });
    describe('#initiateServiceAgreement', () => {
        describe('with valid oracle signatures', () => {
            let serviceAgreement;
            let sAID;
            let receipt;
            beforeEach(async () => {
                serviceAgreement = test_helpers_1.coordinator.serviceAgreement({
                    oracles: [roles.oracleNode],
                    aggregator: emptyAggregator.address,
                });
                sAID = test_helpers_1.coordinator.generateSAID(serviceAgreement);
                const tx = await coord.initiateServiceAgreement(...(await test_helpers_1.coordinator.initiateSAParams(serviceAgreement)));
                receipt = await tx.wait();
            });
            it('saves a service agreement struct from the parameters', async () => {
                const sAID = test_helpers_1.coordinator.generateSAID(serviceAgreement);
                const sa = await coord.serviceAgreements(sAID);
                test_helpers_1.matchers.bigNum(sa.payment, serviceAgreement.payment, 'expected payment');
                test_helpers_1.matchers.bigNum(sa.expiration, serviceAgreement.expiration, 'expected expiration');
                test_helpers_1.matchers.bigNum(sa.endAt, serviceAgreement.endAt, 'expected endAt date');
                chai_1.assert.equal(sa.requestDigest, serviceAgreement.requestDigest, 'expected requestDigest');
            });
            it('generates the SAID', async () => {
                const ethSAID = await coord.getId(test_helpers_1.coordinator.encodeServiceAgreement(serviceAgreement));
                chai_1.assert.equal(ethSAID, sAID);
            });
            it('logs an event', async () => {
                expect(test_helpers_1.helpers.findEventIn(receipt, newServiceAgreementEvent)).toBeDefined();
            });
            it('calls the aggregator with the SA info', async () => {
                const event = test_helpers_1.helpers.findEventIn(receipt, newServiceAgreementEvent);
                chai_1.assert(event, 'event was expected');
                const { said } = test_helpers_1.helpers.eventArgs(test_helpers_1.helpers.findEventIn(receipt, newServiceAgreementEvent));
                chai_1.assert.equal(said, sAID);
            });
        });
        describe('with an invalid oracle signature', () => {
            it('saves no service agreement struct, if signatures invalid', async () => {
                const serviceAgreement = test_helpers_1.coordinator.serviceAgreement({
                    oracles: [roles.oracleNode],
                    aggregator: emptyAggregator.address,
                });
                const sAID = test_helpers_1.coordinator.generateSAID(serviceAgreement);
                const badOracleSignature = await test_helpers_1.coordinator.personalSign(sAID, roles.stranger);
                const badRequestDigestAddr = test_helpers_1.coordinator.recoverAddressFromSignature(sAID, badOracleSignature);
                chai_1.assert.equal(roles.stranger.address, badRequestDigestAddr);
                const conbinedSignatures = test_helpers_1.coordinator.combineOracleSignatures([
                    badOracleSignature,
                ]);
                await test_helpers_1.matchers.evmRevert(coord.initiateServiceAgreement(test_helpers_1.coordinator.encodeServiceAgreement(serviceAgreement), test_helpers_1.coordinator.encodeOracleSignatures(conbinedSignatures)));
                const fetchedServiceAgreement = await coord.serviceAgreements(sAID);
                test_helpers_1.coordinator.assertServiceAgreementEmpty(fetchedServiceAgreement);
            });
        });
        describe('Validation of service agreement deadlines', () => {
            it('Rejects a service agreement with an endAt date in the past', async () => {
                const serviceAgreement = test_helpers_1.coordinator.serviceAgreement({
                    endAt: 1,
                    aggregator: emptyAggregator.address,
                });
                const sAID = test_helpers_1.coordinator.generateSAID(serviceAgreement);
                await test_helpers_1.matchers.evmRevert(coord.initiateServiceAgreement(...(await test_helpers_1.coordinator.initiateSAParams(serviceAgreement))));
                const fetchedServiceAgreement = await coord.serviceAgreements(sAID);
                test_helpers_1.coordinator.assertServiceAgreementEmpty(fetchedServiceAgreement);
            });
        });
    });
    describe('#oracleRequest', () => {
        const to = '0x80e29acb842498fe6591f020bd82766dce619d43';
        let agreement;
        let fHash;
        let sAID;
        beforeEach(async () => {
            fHash = getterSetterFactory.interface.functions.requestedBytes32.sighash;
            agreement = test_helpers_1.coordinator.serviceAgreement({
                oracles: [roles.oracleNode],
                aggregator: meanAggregator.address,
            });
            sAID = test_helpers_1.coordinator.generateSAID(agreement);
            await coord.initiateServiceAgreement(...(await test_helpers_1.coordinator.initiateSAParams(agreement)));
            await link.transfer(roles.consumer.address, test_helpers_1.helpers.toWei('1000'));
        });
        describe('when called through the LINK token with enough payment', () => {
            it('logs an event', async () => {
                var _a, _b, _c, _d;
                const payload = test_helpers_1.coordinator.encodeOracleRequest(sAID, to, fHash, 1, '0x0');
                const tx = await link
                    .connect(roles.consumer)
                    .transferAndCall(coord.address, agreement.payment, payload);
                const receipt = await tx.wait();
                const event = test_helpers_1.helpers.findEventIn(receipt, oracleRequestEvent);
                const { sAId: loggedSAID } = oracleRequestEvent.decode((_b = (_a = event) === null || _a === void 0 ? void 0 : _a.data, (_b !== null && _b !== void 0 ? _b : '')), (_c = event) === null || _c === void 0 ? void 0 : _c.topics);
                const req = test_helpers_1.oracle.decodeRunRequest(event);
                chai_1.assert.equal((_d = event) === null || _d === void 0 ? void 0 : _d.address, coord.address);
                chai_1.assert.equal(sAID, loggedSAID);
                test_helpers_1.matchers.bigNum(roles.consumer.address, req.requester, "Logged consumer address doesn't match");
                test_helpers_1.matchers.bigNum(agreement.payment, req.payment, "Logged payment amount doesn't match");
            });
        });
        describe('when called through the LINK token with not enough payment', () => {
            it('throws an error', async () => {
                const calldata = test_helpers_1.coordinator.encodeOracleRequest(sAID, to, fHash, 1, '0x0');
                const underPaid = test_helpers_1.helpers
                    .bigNum(agreement.payment)
                    .sub(test_helpers_1.helpers.bigNum(1))
                    .toString();
                await test_helpers_1.matchers.evmRevert(link
                    .connect(roles.consumer)
                    .transferAndCall(coord.address, underPaid, calldata));
            });
        });
        describe('when not called through the LINK token', () => {
            it('reverts', async () => {
                const txPromise = coord
                    .connect(roles.consumer)
                    .oracleRequest(ethers_1.ethers.constants.AddressZero, 0, sAID, to, fHash, 1, 1, '0x');
                await test_helpers_1.matchers.evmRevert(txPromise, 'Must use LINK token');
            });
        });
    });
    describe('#fulfillOracleRequest', () => {
        let agreement;
        let sAID;
        let mock;
        let request;
        let fHash;
        beforeEach(async () => {
            var _a, _b, _c;
            agreement = test_helpers_1.coordinator.serviceAgreement({
                oracles: [roles.oracleNode],
                aggregator: meanAggregator.address,
            });
            sAID = test_helpers_1.coordinator.generateSAID(agreement);
            const tx = await coord.initiateServiceAgreement(...(await test_helpers_1.coordinator.initiateSAParams(agreement)));
            const receipt = await tx.wait();
            const event = test_helpers_1.helpers.findEventIn(receipt, newServiceAgreementEvent);
            const { said: loggedSAID } = newServiceAgreementEvent.decode((_b = (_a = event) === null || _a === void 0 ? void 0 : _a.data, (_b !== null && _b !== void 0 ? _b : '')), (_c = event) === null || _c === void 0 ? void 0 : _c.topics);
            chai_1.assert.equal(loggedSAID, sAID);
            fHash = getterSetterFactory.interface.functions.requestedBytes32.sighash;
        });
        describe('cooperative consumer', () => {
            const message = test_helpers_1.helpers.toBytes32String('Hello World!');
            beforeEach(async () => {
                mock = await getterSetterFactory.connect(roles.defaultAccount).deploy();
                const payload = test_helpers_1.coordinator.encodeOracleRequest(sAID, mock.address, fHash, 1, '0x0');
                const tx = await link.transferAndCall(coord.address, agreement.payment, payload);
                const receipt = await tx.wait();
                const eventLog = test_helpers_1.helpers.findEventIn(receipt, oracleRequestEvent);
                request = test_helpers_1.oracle.decodeRunRequest(eventLog);
            });
            describe('when called by a non-owner', () => {
                // Turn this test on when multiple-oracle response aggregation is enabled
                xit('raises an error', async () => {
                    await test_helpers_1.matchers.evmRevert(coord
                        .connect(roles.stranger)
                        .fulfillOracleRequest(request.requestId, message));
                });
            });
            describe('when called by an owner', () => {
                it('raises an error if the request ID does not exist', async () => {
                    const invalidRequestId = test_helpers_1.helpers.toBytes32String('deadbeef');
                    await test_helpers_1.matchers.evmRevert(coord
                        .connect(roles.oracleNode)
                        .fulfillOracleRequest(invalidRequestId, message));
                });
                it('sets the value on the requested contract', async () => {
                    await coord
                        .connect(roles.oracleNode)
                        .fulfillOracleRequest(request.requestId, message);
                    const mockRequestId = await mock.requestId();
                    chai_1.assert.equal(test_helpers_1.helpers.toHex(request.requestId), mockRequestId);
                    const currentValue = await mock.getBytes32();
                    chai_1.assert.equal('Hello World!', test_helpers_1.helpers.parseBytes32String(currentValue));
                });
                it('reports errors from the aggregator, such as double-reporting', async () => {
                    const firstMessage = test_helpers_1.helpers.toBytes32String('First message!');
                    const seccondMessage = test_helpers_1.helpers.toBytes32String('Second message!!');
                    await coord
                        .connect(roles.oracleNode)
                        .fulfillOracleRequest(request.requestId, firstMessage);
                    await test_helpers_1.matchers.evmRevert(coord
                        .connect(roles.oracleNode)
                        .fulfillOracleRequest(request.requestId, seccondMessage), 'oracle already reported');
                });
            });
        });
        describe('with a malicious requester', () => {
            let mock;
            const paymentAmount = test_helpers_1.helpers.toWei('1');
            beforeEach(async () => {
                mock = await maliciousRequesterFactory
                    .connect(roles.defaultAccount)
                    .deploy(link.address, coord.address);
                await link.transfer(mock.address, paymentAmount);
            });
            xit('cannot cancel before the expiration', async () => {
                await test_helpers_1.matchers.evmRevert(mock.maliciousRequestCancel(sAID, 'doesNothing(bytes32,bytes32)'));
            });
            it('cannot call functions on the LINK token through callbacks', async () => {
                await test_helpers_1.matchers.evmRevert(mock.request(sAID, link.address, linkTokenFactory.interface.functions.transfer.sighash));
            });
            describe('requester lies about amount of LINK sent', () => {
                it('the oracle uses the amount of LINK actually paid', async () => {
                    const tx = await mock.maliciousPrice(sAID);
                    const receipt = await tx.wait();
                    const eventLog = test_helpers_1.helpers.findEventIn(receipt, oracleRequestEvent);
                    const req = test_helpers_1.oracle.decodeRunRequest(eventLog);
                    test_helpers_1.matchers.bigNum(paymentAmount, req.payment, [
                        'Malicious data request tricked oracle into refunding more than',
                        'the requester paid, by claiming a larger amount',
                        `(${req.payment}) than the requester paid (${paymentAmount})`,
                    ].join(' '));
                });
            });
        });
        describe('with a malicious consumer', () => {
            const paymentAmount = test_helpers_1.helpers.toWei('1');
            let mock;
            beforeEach(async () => {
                mock = await maliciousConsumerFactory
                    .connect(roles.defaultAccount)
                    .deploy(link.address, coord.address);
                await link.transfer(mock.address, paymentAmount);
            });
            describe('fails during fulfillment', () => {
                beforeEach(async () => {
                    const tx = await mock.requestData(sAID, maliciousConsumerFactory.interface.functions.assertFail.sighash);
                    const receipt = await tx.wait();
                    const eventLog = test_helpers_1.helpers.findEventIn(receipt, oracleRequestEvent);
                    request = test_helpers_1.oracle.decodeRunRequest(eventLog);
                });
                // needs coordinator withdrawal functionality to meet parity
                xit('allows the oracle node to receive their payment', async () => {
                    await coord
                        .connect(roles.oracleNode)
                        .fulfillOracleRequest(request.requestId, test_helpers_1.helpers.toBytes32String('hack the planet 101'));
                    const balance = await link.balanceOf(roles.oracleNode.address);
                    test_helpers_1.matchers.bigNum(balance, 0);
                    await coord
                        .connect(roles.oracleNode)
                        .withdraw(roles.oracleNode.address, paymentAmount);
                    const newBalance = await link.balanceOf(roles.oracleNode.address);
                    test_helpers_1.matchers.bigNum(paymentAmount, newBalance);
                });
                it("can't fulfill the data again", async () => {
                    await coord
                        .connect(roles.oracleNode)
                        .fulfillOracleRequest(request.requestId, test_helpers_1.helpers.toBytes32String('hack the planet 101'));
                    await test_helpers_1.matchers.evmRevert(coord
                        .connect(roles.oracleNode)
                        .fulfillOracleRequest(request.requestId, test_helpers_1.helpers.toBytes32String('hack the planet 102')), 'oracle already reported');
                });
            });
            describe('calls selfdestruct', () => {
                beforeEach(async () => {
                    const tx = await mock.requestData(sAID, maliciousConsumerFactory.interface.functions.doesNothing.sighash);
                    const receipt = await tx.wait();
                    const eventLog = test_helpers_1.helpers.findEventIn(receipt, oracleRequestEvent);
                    request = test_helpers_1.oracle.decodeRunRequest(eventLog);
                    await mock.remove();
                });
                // needs coordinator withdrawal functionality to meet parity
                xit('allows the oracle node to receive their payment', async () => {
                    await coord.fulfillOracleRequest(request.requestId, test_helpers_1.helpers.toBytes32String('hack the planet 101'));
                    const balance = await link.balanceOf(roles.oracleNode.address);
                    test_helpers_1.matchers.bigNum(balance, 0);
                    await coord.withdraw(roles.oracleNode.address, paymentAmount);
                    const newBalance = await link.balanceOf(roles.oracleNode.address);
                    test_helpers_1.matchers.bigNum(paymentAmount, newBalance);
                });
            });
            describe('request is canceled during fulfillment', () => {
                beforeEach(async () => {
                    const tx = await mock.requestData(sAID, maliciousConsumerFactory.interface.functions.cancelRequestOnFulfill
                        .sighash);
                    const receipt = await tx.wait();
                    const eventLog = test_helpers_1.helpers.findEventIn(receipt, oracleRequestEvent);
                    request = test_helpers_1.oracle.decodeRunRequest(eventLog);
                    const mockBalance = await link.balanceOf(mock.address);
                    test_helpers_1.matchers.bigNum(mockBalance, test_helpers_1.helpers.bigNum(0));
                });
                // needs coordinator withdrawal functionality to meet parity
                xit('allows the oracle node to receive their payment', async () => {
                    await coord.fulfillOracleRequest(request.requestId, test_helpers_1.helpers.toBytes32String('hack the planet 101'));
                    const mockBalance = await link.balanceOf(mock.address);
                    test_helpers_1.matchers.bigNum(mockBalance, 0);
                    const balance = await link.balanceOf(roles.oracleNode.address);
                    test_helpers_1.matchers.bigNum(balance, 0);
                    await coord.withdraw(roles.oracleNode.address, paymentAmount);
                    const newBalance = await link.balanceOf(roles.oracleNode.address);
                    test_helpers_1.matchers.bigNum(paymentAmount, newBalance);
                });
                it("can't fulfill the data again", async () => {
                    await coord
                        .connect(roles.oracleNode)
                        .fulfillOracleRequest(request.requestId, test_helpers_1.helpers.toBytes32String('hack the planet 101'));
                    await test_helpers_1.matchers.evmRevert(coord
                        .connect(roles.oracleNode)
                        .fulfillOracleRequest(request.requestId, test_helpers_1.helpers.toBytes32String('hack the planet 102')));
                });
            });
        });
        describe('when aggregating answers', () => {
            let request;
            beforeEach(async () => {
                var _a, _b, _c;
                agreement = test_helpers_1.coordinator.serviceAgreement({
                    aggregator: meanAggregator.address,
                    oracles: [roles.oracleNode1, roles.oracleNode2, roles.oracleNode3],
                });
                sAID = test_helpers_1.coordinator.generateSAID(agreement);
                const tx1 = await coord.initiateServiceAgreement(...(await test_helpers_1.coordinator.initiateSAParams(agreement)));
                const receipt1 = await tx1.wait();
                const event1 = test_helpers_1.helpers.findEventIn(receipt1, newServiceAgreementEvent);
                const { said: loggedSAID } = newServiceAgreementEvent.decode((_b = (_a = event1) === null || _a === void 0 ? void 0 : _a.data, (_b !== null && _b !== void 0 ? _b : '')), (_c = event1) === null || _c === void 0 ? void 0 : _c.topics);
                chai_1.assert.equal(loggedSAID, sAID);
                mock = await getterSetterFactory.connect(roles.defaultAccount).deploy();
                const fHash = getterSetterFactory.interface.functions.requestedUint256.sighash;
                const payload = test_helpers_1.coordinator.encodeOracleRequest(sAID, mock.address, fHash, 1, '0x0');
                const tx2 = await link.transferAndCall(coord.address, agreement.payment, payload);
                const receipt2 = await tx2.wait();
                const event2 = test_helpers_1.helpers.findEventIn(receipt2, oracleRequestEvent);
                request = test_helpers_1.oracle.decodeRunRequest(event2);
            });
            it('does not set the value with only one oracle', async () => {
                var _a;
                const tx = await coord
                    .connect(roles.oracleNode1)
                    .fulfillOracleRequest(request.requestId, test_helpers_1.helpers.numToBytes32(17));
                const receipt = await tx.wait();
                chai_1.assert.equal((_a = receipt.logs) === null || _a === void 0 ? void 0 : _a.length, 0); // No logs emitted = consuming contract not called
            });
            it('sets the average of the reported values', async () => {
                var _a;
                await coord
                    .connect(roles.oracleNode1)
                    .fulfillOracleRequest(request.requestId, test_helpers_1.helpers.numToBytes32(16));
                await coord
                    .connect(roles.oracleNode2)
                    .fulfillOracleRequest(request.requestId, test_helpers_1.helpers.numToBytes32(17));
                const tx = await coord
                    .connect(roles.oracleNode3)
                    .fulfillOracleRequest(request.requestId, test_helpers_1.helpers.numToBytes32(18));
                const receipt = await tx.wait();
                chai_1.assert.equal((_a = receipt.logs) === null || _a === void 0 ? void 0 : _a.length, 1);
                const currentValue = await mock.getUint256();
                test_helpers_1.matchers.bigNum(currentValue, 17);
            });
            describe('when large values are provided in response', () => {
                // (uint256(-1) / 2) - 1
                const largeValue1 = '0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe';
                // (uint256(-1) / 2)
                const largeValue2 = '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';
                // (uint256(-1) / 2) + 1
                const largeValue3 = '0x8000000000000000000000000000000000000000000000000000000000000000';
                beforeEach(async () => {
                    await coord
                        .connect(roles.oracleNode1)
                        .fulfillOracleRequest(request.requestId, largeValue1);
                    await coord
                        .connect(roles.oracleNode2)
                        .fulfillOracleRequest(request.requestId, largeValue2);
                });
                it('does not overflow', async () => {
                    await coord
                        .connect(roles.oracleNode3)
                        .fulfillOracleRequest(request.requestId, largeValue3);
                });
                it('sets the average of the reported values', async () => {
                    await coord
                        .connect(roles.oracleNode3)
                        .fulfillOracleRequest(request.requestId, largeValue3);
                    const currentValue = await mock.getUint256();
                    test_helpers_1.matchers.bigNum(largeValue2, currentValue);
                    chai_1.assert.notEqual(test_helpers_1.helpers.bigNum(0), test_helpers_1.helpers.bigNum(await mock.requestId())); // check if called
                });
            });
            it('successfully sets average when responses equal largest uint256', async () => {
                const largest = '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';
                await coord
                    .connect(roles.oracleNode1)
                    .fulfillOracleRequest(request.requestId, largest);
                await coord
                    .connect(roles.oracleNode2)
                    .fulfillOracleRequest(request.requestId, largest);
                await coord
                    .connect(roles.oracleNode3)
                    .fulfillOracleRequest(request.requestId, largest);
                const currentValue = await mock.getUint256();
                test_helpers_1.matchers.bigNum(test_helpers_1.helpers.bigNum(largest), currentValue);
                chai_1.assert.notEqual(test_helpers_1.helpers.bigNum(0), test_helpers_1.helpers.bigNum(await mock.requestId())); // check if called
            });
            it('rejects oracles not part of the service agreement', async () => {
                await test_helpers_1.matchers.evmRevert(coord
                    .connect(roles.stranger)
                    .fulfillOracleRequest(request.requestId, test_helpers_1.helpers.numToBytes32(18)));
            });
            describe('when an oracle reports multiple times', () => {
                beforeEach(async () => {
                    await coord
                        .connect(roles.oracleNode1)
                        .fulfillOracleRequest(request.requestId, test_helpers_1.helpers.numToBytes32(16));
                    await coord
                        .connect(roles.oracleNode2)
                        .fulfillOracleRequest(request.requestId, test_helpers_1.helpers.numToBytes32(17));
                    await test_helpers_1.matchers.evmRevert(coord
                        .connect(roles.oracleNode1)
                        .fulfillOracleRequest(request.requestId, test_helpers_1.helpers.numToBytes32(18)));
                });
                it('does not set the average', async () => {
                    test_helpers_1.matchers.bigNum(0, await mock.requestId()); // check if called
                });
                it('still allows the other oracles to report', async () => {
                    await coord
                        .connect(roles.oracleNode3)
                        .fulfillOracleRequest(request.requestId, test_helpers_1.helpers.numToBytes32(18));
                    const currentValue = await mock.getUint256();
                    test_helpers_1.matchers.bigNum(test_helpers_1.helpers.bigNum(17), currentValue);
                    chai_1.assert.notEqual(test_helpers_1.helpers.bigNum(0), test_helpers_1.helpers.bigNum(await mock.requestId())); // check if called
                });
            });
        });
        describe('after aggregation', () => {
            let request;
            beforeEach(async () => {
                var _a, _b, _c;
                agreement = test_helpers_1.coordinator.serviceAgreement({
                    aggregator: meanAggregator.address,
                    oracles: [roles.oracleNode1, roles.oracleNode2, roles.oracleNode3],
                });
                sAID = test_helpers_1.coordinator.generateSAID(agreement);
                const tx1 = await coord.initiateServiceAgreement(...(await test_helpers_1.coordinator.initiateSAParams(agreement)));
                const receipt1 = await tx1.wait();
                const event1 = test_helpers_1.helpers.findEventIn(receipt1, newServiceAgreementEvent);
                const { said: loggedSAID } = newServiceAgreementEvent.decode((_b = (_a = event1) === null || _a === void 0 ? void 0 : _a.data, (_b !== null && _b !== void 0 ? _b : '')), (_c = event1) === null || _c === void 0 ? void 0 : _c.topics);
                chai_1.assert.equal(loggedSAID, sAID);
                mock = await getterSetterFactory.connect(roles.defaultAccount).deploy();
                const fHash = getterSetterFactory.interface.functions.requestedUint256.sighash;
                const payload = test_helpers_1.coordinator.encodeOracleRequest(sAID, mock.address, fHash, 1, '0x0');
                const tx = await link.transferAndCall(coord.address, agreement.payment, payload);
                const receipt = await tx.wait();
                const eventLog = test_helpers_1.helpers.findEventIn(receipt, oracleRequestEvent);
                request = test_helpers_1.oracle.decodeRunRequest(eventLog);
                await coord
                    .connect(roles.oracleNode1)
                    .fulfillOracleRequest(request.requestId, test_helpers_1.helpers.numToBytes32(16));
                await coord
                    .connect(roles.oracleNode2)
                    .fulfillOracleRequest(request.requestId, test_helpers_1.helpers.numToBytes32(17));
                await coord
                    .connect(roles.oracleNode3)
                    .fulfillOracleRequest(request.requestId, test_helpers_1.helpers.numToBytes32(18));
                const currentValue = await mock.getUint256();
                test_helpers_1.matchers.bigNum(test_helpers_1.helpers.bigNum(17), currentValue);
            });
            it('oracle balances are updated', async () => {
                // Given the 3 oracles from the SA, each should have the following balance after fulfillment
                const expected1 = test_helpers_1.helpers.bigNum('555555555555555555');
                const expected2 = test_helpers_1.helpers.bigNum('333333333333333333');
                const expected3 = test_helpers_1.helpers.bigNum('111111111111111111');
                const balance1 = await coord.withdrawableTokens(oracle1);
                const balance2 = await coord.withdrawableTokens(oracle2);
                const balance3 = await coord.withdrawableTokens(oracle3);
                test_helpers_1.matchers.bigNum(expected1, balance1);
                test_helpers_1.matchers.bigNum(expected2, balance2);
                test_helpers_1.matchers.bigNum(expected3, balance3);
            });
        });
        describe('withdraw', () => {
            let request;
            beforeEach(async () => {
                var _a, _b, _c;
                agreement = test_helpers_1.coordinator.serviceAgreement({
                    aggregator: meanAggregator.address,
                    oracles: [roles.oracleNode1, roles.oracleNode2, roles.oracleNode3],
                });
                sAID = test_helpers_1.coordinator.generateSAID(agreement);
                const tx1 = await coord.initiateServiceAgreement(...(await test_helpers_1.coordinator.initiateSAParams(agreement)));
                const receipt1 = await tx1.wait();
                const event1 = test_helpers_1.helpers.findEventIn(receipt1, newServiceAgreementEvent);
                const { said: loggedSAID } = newServiceAgreementEvent.decode((_b = (_a = event1) === null || _a === void 0 ? void 0 : _a.data, (_b !== null && _b !== void 0 ? _b : '')), (_c = event1) === null || _c === void 0 ? void 0 : _c.topics);
                chai_1.assert.equal(loggedSAID, sAID);
                mock = await getterSetterFactory.connect(roles.defaultAccount).deploy();
                const fHash = getterSetterFactory.interface.functions.requestedUint256.sighash;
                const payload = test_helpers_1.coordinator.encodeOracleRequest(sAID, mock.address, fHash, 1, '0x0');
                const tx2 = await link.transferAndCall(coord.address, agreement.payment, payload);
                const receipt2 = await tx2.wait();
                const event2 = test_helpers_1.helpers.findEventIn(receipt2, oracleRequestEvent);
                request = test_helpers_1.oracle.decodeRunRequest(event2);
                await coord
                    .connect(roles.oracleNode1)
                    .fulfillOracleRequest(request.requestId, test_helpers_1.helpers.numToBytes32(16));
                await coord
                    .connect(roles.oracleNode2)
                    .fulfillOracleRequest(request.requestId, test_helpers_1.helpers.numToBytes32(17));
                await coord
                    .connect(roles.oracleNode3)
                    .fulfillOracleRequest(request.requestId, test_helpers_1.helpers.numToBytes32(18));
                const currentValue = await mock.getUint256();
                test_helpers_1.matchers.bigNum(test_helpers_1.helpers.bigNum(17), currentValue);
            });
            it('allows the oracle to withdraw their full amount', async () => {
                const coordBalance1 = await link.balanceOf(coord.address);
                const withdrawAmount = await coord.withdrawableTokens(oracle1);
                await coord.connect(roles.oracleNode1).withdraw(oracle1, withdrawAmount);
                const oracleBalance = await link.balanceOf(oracle1);
                const afterWithdrawBalance = await coord
                    .connect(roles.oracleNode1)
                    .withdrawableTokens(oracle1);
                const coordBalance2 = await link.balanceOf(coord.address);
                const expectedCoordFinalBalance = coordBalance1.sub(withdrawAmount);
                test_helpers_1.matchers.bigNum(withdrawAmount, oracleBalance);
                test_helpers_1.matchers.bigNum(expectedCoordFinalBalance, coordBalance2);
                test_helpers_1.matchers.bigNum(test_helpers_1.helpers.bigNum(0), afterWithdrawBalance);
            });
            it('rejects amounts greater than allowed', async () => {
                const oracleBalance = await coord.withdrawableTokens(oracle1);
                const withdrawAmount = oracleBalance.add(test_helpers_1.helpers.bigNum(1));
                await test_helpers_1.matchers.evmRevert(coord.connect(roles.oracleNode1).withdraw(oracle1, withdrawAmount));
            });
        });
    });
    describe('#depositFunds', () => {
        async function assertBalances({ link: linkBal, coordinator: coordBal, }) {
            const linkBalance = await link.balanceOf(oracle1);
            const coordinatorBalance = await coord.balanceOf(oracle1);
            test_helpers_1.matchers.bigNum(linkBalance, linkBal);
            test_helpers_1.matchers.bigNum(coordinatorBalance, coordBal);
        }
        beforeEach(async () => {
            await link.transfer(oracle1, 4);
            const initialBalance = await link.balanceOf(oracle1);
            test_helpers_1.matchers.bigNum(initialBalance, 4);
        });
        it('permits deposit through link#transferAndCall', async () => {
            const payload = coordinatorFactory.interface.functions.depositFunds.encode([oracle1, 1]);
            await link
                .connect(roles.oracleNode1)
                .transferAndCall(coord.address, 1, payload);
            await assertBalances({ link: 3, coordinator: 1 });
        });
        it('overrides invalid payloads', async () => {
            const payload = coordinatorFactory.interface.functions.depositFunds.encode([coord.address, 2]);
            await link
                .connect(roles.oracleNode1)
                .transferAndCall(coord.address, 1, payload);
            await assertBalances({ link: 3, coordinator: 1 });
        });
        it('reverts with insufficient payloads', async () => {
            const payload = coordinatorFactory.interface.functions.depositFunds.sighash;
            await test_helpers_1.matchers.evmRevert(link
                .connect(roles.oracleNode1)
                .transferAndCall(coord.address, 1, payload));
        });
        it('allows partial withdrawals', async () => {
            const payload = coordinatorFactory.interface.functions.depositFunds.encode([oracle1, 4]);
            await link
                .connect(roles.oracleNode1)
                .transferAndCall(coord.address, 4, payload);
            await coord.connect(roles.oracleNode1).withdraw(oracle1, 1);
            await assertBalances({ link: 1, coordinator: 3 });
        });
        it('allows full withdrawals', async () => {
            const payload = coordinatorFactory.interface.functions.depositFunds.encode([oracle1, 4]);
            await link
                .connect(roles.oracleNode1)
                .transferAndCall(coord.address, 4, payload);
            await coord.connect(roles.oracleNode1).withdraw(oracle1, 2);
            await coord.connect(roles.oracleNode1).withdraw(oracle1, 2);
            await assertBalances({ link: 4, coordinator: 0 });
        });
        it('reverts when overdrawing', async () => {
            const payload = coordinatorFactory.interface.functions.depositFunds.encode([oracle1, 4]);
            await link
                .connect(roles.oracleNode1)
                .transferAndCall(coord.address, 4, payload);
            await coord.connect(roles.oracleNode1).withdraw(oracle1, 4);
            await test_helpers_1.matchers.evmRevert(coord.connect(roles.oracleNode1).withdraw(oracle1, 1));
            await assertBalances({ link: 4, coordinator: 0 });
        });
    });
});
//# sourceMappingURL=Coordinator.test.js.map