"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const test_helpers_1 = require("@chainlink/test-helpers");
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const ChainlinkTestHelperFactory_1 = require("../src/generated/ChainlinkTestHelperFactory");
const chainlinkFactory = new ChainlinkTestHelperFactory_1.ChainlinkTestHelperFactory();
const provider = test_helpers_1.setup.provider();
let defaultAccount;
beforeAll(async () => {
    defaultAccount = await test_helpers_1.setup.users(provider).then(x => x.roles.defaultAccount);
});
describe('Chainlink', () => {
    let cl;
    let clEvents;
    const deployment = test_helpers_1.setup.snapshot(provider, async () => {
        cl = await chainlinkFactory.connect(defaultAccount).deploy();
        clEvents = cl.interface.events;
    });
    beforeEach(async () => {
        await deployment();
    });
    it('has a limited public interface', () => {
        test_helpers_1.matchers.publicAbi(chainlinkFactory, [
            'add',
            'addBytes',
            'addInt',
            'addStringArray',
            'addUint',
            'closeEvent',
            'setBuffer',
        ]);
    });
    function getPayloadFrom(receipt) {
        const { payload } = test_helpers_1.helpers.eventArgs(test_helpers_1.helpers.findEventIn(receipt, clEvents.RequestData));
        const decoded = test_helpers_1.helpers.decodeDietCBOR(payload);
        return decoded;
    }
    describe('#close', () => {
        it('handles empty payloads', async () => {
            const tx = await cl.closeEvent();
            const receipt = await tx.wait();
            const decoded = getPayloadFrom(receipt);
            chai_1.assert.deepEqual(decoded, {});
        });
    });
    describe('#setBuffer', () => {
        it('emits the buffer', async () => {
            await cl.setBuffer('0xA161616162');
            const tx = await cl.closeEvent();
            const receipt = await tx.wait();
            const decoded = getPayloadFrom(receipt);
            chai_1.assert.deepEqual(decoded, { a: 'b' });
        });
    });
    describe('#add', () => {
        it('stores and logs keys and values', async () => {
            await cl.add('first', 'word!!');
            const tx = await cl.closeEvent();
            const receipt = await tx.wait();
            const decoded = getPayloadFrom(receipt);
            chai_1.assert.deepEqual(decoded, { first: 'word!!' });
        });
        it('handles two entries', async () => {
            await cl.add('first', 'uno');
            await cl.add('second', 'dos');
            const tx = await cl.closeEvent();
            const receipt = await tx.wait();
            const decoded = getPayloadFrom(receipt);
            chai_1.assert.deepEqual(decoded, {
                first: 'uno',
                second: 'dos',
            });
        });
    });
    describe('#addBytes', () => {
        it('stores and logs keys and values', async () => {
            await cl.addBytes('first', '0xaabbccddeeff');
            const tx = await cl.closeEvent();
            const receipt = await tx.wait();
            const decoded = getPayloadFrom(receipt);
            const expected = test_helpers_1.helpers.hexToBuf('0xaabbccddeeff');
            chai_1.assert.deepEqual(decoded, { first: expected });
        });
        it('handles two entries', async () => {
            await cl.addBytes('first', '0x756E6F');
            await cl.addBytes('second', '0x646F73');
            const tx = await cl.closeEvent();
            const receipt = await tx.wait();
            const decoded = getPayloadFrom(receipt);
            const expectedFirst = test_helpers_1.helpers.hexToBuf('0x756E6F');
            const expectedSecond = test_helpers_1.helpers.hexToBuf('0x646F73');
            chai_1.assert.deepEqual(decoded, {
                first: expectedFirst,
                second: expectedSecond,
            });
        });
        it('handles strings', async () => {
            await cl.addBytes('first', ethers_1.ethers.utils.toUtf8Bytes('apple'));
            const tx = await cl.closeEvent();
            const receipt = await tx.wait();
            const decoded = getPayloadFrom(receipt);
            const expected = ethers_1.ethers.utils.toUtf8Bytes('apple');
            chai_1.assert.deepEqual(decoded, { first: expected });
        });
    });
    describe('#addInt', () => {
        it('stores and logs keys and values', async () => {
            await cl.addInt('first', 1);
            const tx = await cl.closeEvent();
            const receipt = await tx.wait();
            const decoded = getPayloadFrom(receipt);
            chai_1.assert.deepEqual(decoded, { first: 1 });
        });
        it('handles two entries', async () => {
            await cl.addInt('first', 1);
            await cl.addInt('second', 2);
            const tx = await cl.closeEvent();
            const receipt = await tx.wait();
            const decoded = getPayloadFrom(receipt);
            chai_1.assert.deepEqual(decoded, {
                first: 1,
                second: 2,
            });
        });
    });
    describe('#addUint', () => {
        it('stores and logs keys and values', async () => {
            await cl.addUint('first', 1);
            const tx = await cl.closeEvent();
            const receipt = await tx.wait();
            const decoded = getPayloadFrom(receipt);
            chai_1.assert.deepEqual(decoded, { first: 1 });
        });
        it('handles two entries', async () => {
            await cl.addUint('first', 1);
            await cl.addUint('second', 2);
            const tx = await cl.closeEvent();
            const receipt = await tx.wait();
            const decoded = getPayloadFrom(receipt);
            chai_1.assert.deepEqual(decoded, {
                first: 1,
                second: 2,
            });
        });
    });
    describe('#addStringArray', () => {
        it('stores and logs keys and values', async () => {
            await cl.addStringArray('word', [
                ethers_1.ethers.utils.formatBytes32String('seinfeld'),
                ethers_1.ethers.utils.formatBytes32String('"4"'),
                ethers_1.ethers.utils.formatBytes32String('LIFE'),
            ]);
            const tx = await cl.closeEvent();
            const receipt = await tx.wait();
            const decoded = getPayloadFrom(receipt);
            chai_1.assert.deepEqual(decoded, { word: ['seinfeld', '"4"', 'LIFE'] });
        });
    });
});
//# sourceMappingURL=Chainlink.test.js.map