"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const test_helpers_1 = require("@chainlink/test-helpers");
const cbor_1 = __importDefault(require("cbor"));
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const generated_1 = require("../src/generated");
const provider = test_helpers_1.setup.provider();
const oracleFactory = new generated_1.OracleFactory();
const preCoordinatorFactory = new generated_1.PreCoordinatorFactory();
const requesterConsumerFactory = new generated_1.BasicConsumerFactory();
const linkTokenFactory = new test_helpers_1.contract.LinkTokenFactory();
let roles;
beforeAll(async () => {
    roles = await test_helpers_1.setup.users(provider).then(x => x.roles);
});
describe('PreCoordinator', () => {
    // These parameters are used to validate the data was received
    // on the deployed oracle contract. The Job ID only represents
    // the type of data, but will not work on a public testnet.
    // For the latest JobIDs, visit our docs here:
    // https://docs.chain.link/docs/testnet-oracles
    const job1 = '0x4c7b7ffb66b344fbaa64995af81e355a00000000000000000000000000000000';
    const job2 = '0x4c7b7ffb66b344fbaa64995af81e355b00000000000000000000000000000000';
    const job3 = '0x4c7b7ffb66b344fbaa64995af81e355c00000000000000000000000000000000';
    const job4 = '0x4c7b7ffb66b344fbaa64995af81e355d00000000000000000000000000000000';
    const currency = 'USD';
    // Represents 1 LINK for testnet requests
    const payment = test_helpers_1.helpers.toWei('1');
    const totalPayment = test_helpers_1.helpers.toWei('4');
    let link;
    let oc1;
    let oc2;
    let oc3;
    let oc4;
    let rc;
    let pc;
    const deployment = test_helpers_1.setup.snapshot(provider, async () => {
        link = await linkTokenFactory.connect(roles.defaultAccount).deploy();
        oc1 = await oracleFactory.connect(roles.defaultAccount).deploy(link.address);
        oc2 = await oracleFactory.connect(roles.defaultAccount).deploy(link.address);
        oc3 = await oracleFactory.connect(roles.defaultAccount).deploy(link.address);
        oc4 = await oracleFactory.connect(roles.defaultAccount).deploy(link.address);
        pc = await preCoordinatorFactory
            .connect(roles.defaultAccount)
            .deploy(link.address);
        await oc1
            .connect(roles.defaultAccount)
            .setFulfillmentPermission(roles.oracleNode1.address, true);
        await oc2
            .connect(roles.defaultAccount)
            .setFulfillmentPermission(roles.oracleNode2.address, true);
        await oc3
            .connect(roles.defaultAccount)
            .setFulfillmentPermission(roles.oracleNode3.address, true);
        await oc4
            .connect(roles.defaultAccount)
            .setFulfillmentPermission(roles.oracleNode4.address, true);
    });
    beforeEach(deployment);
    describe('#createServiceAgreement', () => {
        describe('when called by the owner', () => {
            it('emits the NewServiceAgreement log', async () => {
                const tx = await pc
                    .connect(roles.defaultAccount)
                    .createServiceAgreement(3, [oc1.address, oc2.address, oc3.address, oc4.address], [job1, job2, job3, job4], [payment, payment, payment, payment]);
                const receipt = await tx.wait();
                expect(test_helpers_1.helpers.findEventIn(receipt, pc.interface.events.NewServiceAgreement)).toBeDefined();
            });
            it('creates a service agreement', async () => {
                const tx = await pc
                    .connect(roles.defaultAccount)
                    .createServiceAgreement(3, [oc1.address, oc2.address, oc3.address, oc4.address], [job1, job2, job3, job4], [payment, payment, payment, payment]);
                const receipt = await tx.wait();
                const { saId } = test_helpers_1.helpers.eventArgs(test_helpers_1.helpers.findEventIn(receipt, pc.interface.events.NewServiceAgreement));
                const sa = await pc.getServiceAgreement(saId);
                chai_1.assert.isTrue(sa.totalPayment.eq(totalPayment));
                chai_1.assert.equal(sa.minResponses.toNumber(), 3);
                chai_1.assert.deepEqual(sa.oracles, [
                    oc1.address,
                    oc2.address,
                    oc3.address,
                    oc4.address,
                ]);
                chai_1.assert.deepEqual(sa.jobIds, [job1, job2, job3, job4]);
                chai_1.assert.deepEqual(sa.payments, [payment, payment, payment, payment]);
            });
            it('does not allow service agreements with 0 minResponses', () => test_helpers_1.matchers.evmRevert(pc
                .connect(roles.defaultAccount)
                .createServiceAgreement(0, [oc1.address, oc2.address, oc3.address, oc4.address], [job1, job2, job3, job4], [payment, payment, payment, payment]), 'Min responses must be > 0'));
            describe('when called by a stranger', () => {
                it('reverts', () => test_helpers_1.matchers.evmRevert(pc
                    .connect(roles.stranger)
                    .createServiceAgreement(3, [oc1.address, oc2.address, oc3.address, oc4.address], [job1, job2, job3, job4], [payment, payment, payment, payment])));
            });
            describe('when the array lengths are not equal', () => {
                it('reverts', () => test_helpers_1.matchers.evmRevert(pc
                    .connect(roles.defaultAccount)
                    .createServiceAgreement(3, [oc1.address, oc2.address, oc3.address, oc4.address], [job1, job2, job3], [payment, payment, payment, payment]), 'Unmet length'));
            });
            describe('when the min responses is greater than the oracles', () => {
                it('reverts', () => test_helpers_1.matchers.evmRevert(pc
                    .connect(roles.defaultAccount)
                    .createServiceAgreement(5, [oc1.address, oc2.address, oc3.address, oc4.address], [job1, job2, job3, job4], [payment, payment, payment, payment]), 'Invalid min responses'));
            });
        });
    });
    describe('#deleteServiceAgreement', () => {
        let saId;
        beforeEach(async () => {
            const tx = await pc
                .connect(roles.defaultAccount)
                .createServiceAgreement(3, [oc1.address, oc2.address, oc3.address, oc4.address], [job1, job2, job3, job4], [payment, payment, payment, payment]);
            const receipt = await tx.wait();
            saId = test_helpers_1.helpers.eventArgs(test_helpers_1.helpers.findEventIn(receipt, pc.interface.events.NewServiceAgreement)).saId;
        });
        describe('when called by a stranger', () => {
            it('reverts', () => test_helpers_1.matchers.evmRevert(pc.connect(roles.stranger).deleteServiceAgreement(saId)));
        });
        describe('when called by the owner', () => {
            it('deletes the service agreement', async () => {
                await pc.connect(roles.defaultAccount).deleteServiceAgreement(saId);
                const sa = await pc.getServiceAgreement(saId);
                chai_1.assert.equal(sa.totalPayment.toNumber(), 0);
                chai_1.assert.equal(sa.minResponses.toNumber(), 0);
                chai_1.assert.deepEqual(sa.oracles, []);
                chai_1.assert.deepEqual(sa.jobIds, []);
                chai_1.assert.deepEqual(sa.payments, []);
            });
        });
        describe('when the service agreement is still active', () => {
            beforeEach(async () => {
                rc = await requesterConsumerFactory
                    .connect(roles.consumer)
                    .deploy(link.address, pc.address, saId);
                await link.transfer(rc.address, totalPayment);
                await rc
                    .connect(roles.consumer)
                    .requestEthereumPrice(currency, totalPayment);
            });
            it('reverts', () => test_helpers_1.matchers.evmRevert(pc.connect(roles.defaultAccount).deleteServiceAgreement(saId), 'Cannot delete while active'));
        });
    });
    describe('#onTokenTransfer', () => {
        describe('when called by an address other than the LINK token', () => {
            it('reverts', async () => {
                const notLink = await linkTokenFactory
                    .connect(roles.defaultAccount)
                    .deploy();
                const tx = await pc
                    .connect(roles.defaultAccount)
                    .createServiceAgreement(3, [oc1.address, oc2.address, oc3.address, oc4.address], [job1, job2, job3, job4], [payment, payment, payment, payment]);
                const receipt = await tx.wait();
                const saId = test_helpers_1.helpers.eventArgs(test_helpers_1.helpers.findEventIn(receipt, pc.interface.events.NewServiceAgreement)).saId;
                const badRc = await requesterConsumerFactory
                    .connect(roles.consumer)
                    .deploy(notLink.address, pc.address, saId);
                await notLink
                    .connect(roles.defaultAccount)
                    .transfer(badRc.address, totalPayment);
                await test_helpers_1.matchers.evmRevert(badRc
                    .connect(roles.consumer)
                    .requestEthereumPrice(currency, totalPayment, {}));
            });
        });
        describe('when called by the LINK token', () => {
            let saId;
            beforeEach(async () => {
                const tx = await pc
                    .connect(roles.defaultAccount)
                    .createServiceAgreement(3, [oc1.address, oc2.address, oc3.address, oc4.address], [job1, job2, job3, job4], [payment, payment, payment, payment]);
                const receipt = await tx.wait();
                saId = test_helpers_1.helpers.eventArgs(test_helpers_1.helpers.findEventIn(receipt, pc.interface.events.NewServiceAgreement)).saId;
                rc = await requesterConsumerFactory
                    .connect(roles.consumer)
                    .deploy(link.address, pc.address, saId);
                await link.transfer(rc.address, totalPayment);
            });
            it('creates Chainlink requests', async () => {
                var _a, _b, _c, _d, _e, _f, _g, _h;
                const tx = await rc
                    .connect(roles.consumer)
                    .requestEthereumPrice(currency, totalPayment);
                const receipt = await tx.wait();
                const log1 = (_a = receipt.logs) === null || _a === void 0 ? void 0 : _a[7];
                chai_1.assert.equal(oc1.address, (_b = log1) === null || _b === void 0 ? void 0 : _b.address);
                const request1 = test_helpers_1.oracle.decodeRunRequest(log1);
                chai_1.assert.equal(request1.requester, pc.address);
                const log2 = (_c = receipt.logs) === null || _c === void 0 ? void 0 : _c[11];
                chai_1.assert.equal(oc2.address, (_d = log2) === null || _d === void 0 ? void 0 : _d.address);
                const request2 = test_helpers_1.oracle.decodeRunRequest(log2);
                chai_1.assert.equal(request2.requester, pc.address);
                const log3 = (_e = receipt.logs) === null || _e === void 0 ? void 0 : _e[15];
                chai_1.assert.equal(oc3.address, (_f = log3) === null || _f === void 0 ? void 0 : _f.address);
                const request3 = test_helpers_1.oracle.decodeRunRequest(log3);
                chai_1.assert.equal(request3.requester, pc.address);
                const log4 = (_g = receipt.logs) === null || _g === void 0 ? void 0 : _g[19];
                chai_1.assert.equal(oc4.address, (_h = log4) === null || _h === void 0 ? void 0 : _h.address);
                const request4 = test_helpers_1.oracle.decodeRunRequest(log4);
                chai_1.assert.equal(request4.requester, pc.address);
                const expected = {
                    path: ['USD'],
                    get: 'https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD,EUR,JPY',
                };
                chai_1.assert.deepEqual(expected, await cbor_1.default.decodeFirst(request1.data));
                chai_1.assert.deepEqual(expected, await cbor_1.default.decodeFirst(request2.data));
                chai_1.assert.deepEqual(expected, await cbor_1.default.decodeFirst(request3.data));
                chai_1.assert.deepEqual(expected, await cbor_1.default.decodeFirst(request4.data));
                const serviceAgreement = await pc.getServiceAgreement(saId);
                chai_1.assert.isTrue(ethers_1.ethers.constants.One.eq(serviceAgreement.activeRequests));
            });
            describe('when insufficient payment is supplied', () => {
                it('reverts', () => test_helpers_1.matchers.evmRevert(rc.connect(roles.consumer).requestEthereumPrice(currency, payment)));
            });
            describe('when the same nonce is used twice', () => {
                const nonce = 1;
                const fHash = '0xabcd1234';
                let args;
                beforeEach(async () => {
                    args = test_helpers_1.oracle.encodeOracleRequest(saId, rc.address, fHash, nonce, '0x0');
                    await link.transferAndCall(pc.address, totalPayment, args);
                });
                it('reverts', () => test_helpers_1.matchers.evmRevert(link.transferAndCall(pc.address, totalPayment, args)));
            });
            describe('when too much payment is supplied', () => {
                it('sends the extra back to the requester', async () => {
                    await link.transfer(rc.address, payment);
                    const extraPayment = test_helpers_1.helpers.toWei('5');
                    const beforeBalance = await link.balanceOf(rc.address);
                    expect(beforeBalance.eq(extraPayment)).toBeTruthy();
                    await rc
                        .connect(roles.consumer)
                        .requestEthereumPrice(currency, extraPayment);
                    const afterBalance = await link.balanceOf(rc.address);
                    expect(afterBalance.eq(payment)).toBeTruthy();
                });
            });
        });
    });
    describe('#chainlinkCallback', () => {
        let saId;
        let request1;
        let request2;
        let request3;
        let request4;
        const response1 = test_helpers_1.helpers.numToBytes32(100);
        const response2 = test_helpers_1.helpers.numToBytes32(101);
        const response3 = test_helpers_1.helpers.numToBytes32(102);
        const response4 = test_helpers_1.helpers.numToBytes32(103);
        beforeEach(async () => {
            const tx = await pc
                .connect(roles.defaultAccount)
                .createServiceAgreement(3, [oc1.address, oc2.address, oc3.address, oc4.address], [job1, job2, job3, job4], [payment, payment, payment, payment]);
            const receipt = await tx.wait();
            saId = test_helpers_1.helpers.eventArgs(test_helpers_1.helpers.findEventIn(receipt, pc.interface.events.NewServiceAgreement)).saId;
            rc = await requesterConsumerFactory
                .connect(roles.consumer)
                .deploy(link.address, pc.address, saId);
            await link.transfer(rc.address, totalPayment);
        });
        describe('when the requester and consumer are the same', () => {
            beforeEach(async () => {
                var _a, _b, _c, _d;
                const reqTx = await rc
                    .connect(roles.consumer)
                    .requestEthereumPrice(currency, totalPayment);
                const receipt = await reqTx.wait();
                const log1 = (_a = receipt.logs) === null || _a === void 0 ? void 0 : _a[7];
                request1 = test_helpers_1.oracle.decodeRunRequest(log1);
                const log2 = (_b = receipt.logs) === null || _b === void 0 ? void 0 : _b[11];
                request2 = test_helpers_1.oracle.decodeRunRequest(log2);
                const log3 = (_c = receipt.logs) === null || _c === void 0 ? void 0 : _c[15];
                request3 = test_helpers_1.oracle.decodeRunRequest(log3);
                const log4 = (_d = receipt.logs) === null || _d === void 0 ? void 0 : _d[19];
                request4 = test_helpers_1.oracle.decodeRunRequest(log4);
            });
            describe('when called by a stranger', () => {
                it('reverts', () => test_helpers_1.matchers.evmRevert(pc.chainlinkCallback(saId, response1), 'Source must be the oracle of the request'));
            });
            describe('when called by the oracle contract', () => {
                it('records the answer', async () => {
                    var _a;
                    const tx = await oc1
                        .connect(roles.oracleNode1)
                        .fulfillOracleRequest(request1.requestId, request1.payment, request1.callbackAddr, request1.callbackFunc, request1.expiration, response1);
                    const receipt = await tx.wait();
                    expect((_a = receipt.events) === null || _a === void 0 ? void 0 : _a[0].topics.find(t => t === pc.interface.events.ChainlinkFulfilled.topic)).toBeDefined();
                });
            });
            describe('when the minimum number of responses have returned', () => {
                beforeEach(async () => {
                    await oc1
                        .connect(roles.oracleNode1)
                        .fulfillOracleRequest(request1.requestId, request1.payment, request1.callbackAddr, request1.callbackFunc, request1.expiration, response1);
                    await oc2
                        .connect(roles.oracleNode2)
                        .fulfillOracleRequest(request2.requestId, request2.payment, request2.callbackAddr, request2.callbackFunc, request2.expiration, response2);
                    await oc3
                        .connect(roles.oracleNode3)
                        .fulfillOracleRequest(request3.requestId, request3.payment, request3.callbackAddr, request3.callbackFunc, request3.expiration, response3);
                });
                it('returns the median to the requesting contract', async () => {
                    const currentPrice = await rc.currentPrice();
                    chai_1.assert.equal(currentPrice, response2);
                });
                describe('when an oracle responds after aggregation', () => {
                    it('does not update the requesting contract', async () => {
                        await oc4
                            .connect(roles.oracleNode4)
                            .fulfillOracleRequest(request4.requestId, request4.payment, request4.callbackAddr, request4.callbackFunc, request4.expiration, response4);
                        const currentPrice = await rc.currentPrice();
                        chai_1.assert.equal(currentPrice, response2);
                    });
                });
            });
        });
        describe('when consumer is different than requester', () => {
            let cc;
            let request1;
            let request2;
            let request3;
            let request4;
            let localRequestId;
            beforeEach(async () => {
                var _a, _b, _c, _d, _e;
                cc = await requesterConsumerFactory
                    .connect(roles.consumer)
                    .deploy(link.address, pc.address, saId);
                const reqTx = await rc
                    .connect(roles.consumer)
                    .requestEthereumPriceByCallback(currency, totalPayment, cc.address);
                const receipt = await reqTx.wait();
                localRequestId = test_helpers_1.helpers.eventArgs((_a = receipt.events) === null || _a === void 0 ? void 0 : _a[0]).id;
                const log1 = (_b = receipt.logs) === null || _b === void 0 ? void 0 : _b[7];
                request1 = test_helpers_1.oracle.decodeRunRequest(log1);
                const log2 = (_c = receipt.logs) === null || _c === void 0 ? void 0 : _c[11];
                request2 = test_helpers_1.oracle.decodeRunRequest(log2);
                const log3 = (_d = receipt.logs) === null || _d === void 0 ? void 0 : _d[15];
                request3 = test_helpers_1.oracle.decodeRunRequest(log3);
                const log4 = (_e = receipt.logs) === null || _e === void 0 ? void 0 : _e[19];
                request4 = test_helpers_1.oracle.decodeRunRequest(log4);
                await cc
                    .connect(roles.consumer)
                    .addExternalRequest(pc.address, localRequestId);
            });
            describe('and the number of responses have been met', () => {
                beforeEach(async () => {
                    await oc1
                        .connect(roles.oracleNode1)
                        .fulfillOracleRequest(request1.requestId, request1.payment, request1.callbackAddr, request1.callbackFunc, request1.expiration, response1);
                    await oc2
                        .connect(roles.oracleNode2)
                        .fulfillOracleRequest(request2.requestId, request2.payment, request2.callbackAddr, request2.callbackFunc, request2.expiration, response2);
                    await oc3
                        .connect(roles.oracleNode3)
                        .fulfillOracleRequest(request3.requestId, request3.payment, request3.callbackAddr, request3.callbackFunc, request3.expiration, response3);
                    await oc4
                        .connect(roles.oracleNode4)
                        .fulfillOracleRequest(request4.requestId, request4.payment, request4.callbackAddr, request4.callbackFunc, request4.expiration, response4);
                });
                it('sends the answer to the consumer', async () => {
                    const currentPrice = await cc.currentPrice();
                    chai_1.assert.equal(currentPrice, response2);
                });
            });
        });
    });
    describe('#withdrawLink', () => {
        beforeEach(async () => {
            await link.transfer(pc.address, payment);
            const actual = await link.balanceOf(pc.address);
            const expected = payment;
            expect(actual.eq(expected)).toBeTruthy();
        });
        describe('when called by a stranger', () => {
            it('reverts', () => test_helpers_1.matchers.evmRevert(pc.connect(roles.stranger).withdrawLink()));
        });
        describe('when called by the owner', () => {
            it('allows the owner to withdraw LINK', async () => {
                await pc.connect(roles.defaultAccount).withdrawLink();
                const actual = await link.balanceOf(pc.address);
                expect(actual.eq(ethers_1.ethers.constants.Zero)).toBeTruthy();
            });
        });
    });
    describe('#cancelOracleRequest', () => {
        let request;
        beforeEach(async () => {
            var _a;
            const tx = await pc
                .connect(roles.defaultAccount)
                .createServiceAgreement(3, [oc1.address, oc2.address, oc3.address, oc4.address], [job1, job2, job3, job4], [payment, payment, payment, payment]);
            const receipt = await tx.wait();
            const saId = test_helpers_1.helpers.eventArgs(test_helpers_1.helpers.findEventIn(receipt, pc.interface.events.NewServiceAgreement)).saId;
            rc = await requesterConsumerFactory
                .connect(roles.consumer)
                .deploy(link.address, pc.address, saId);
            await link.transfer(rc.address, totalPayment);
            const reqTx = await rc
                .connect(roles.consumer)
                .requestEthereumPrice(currency, totalPayment);
            const reqReceipt = await reqTx.wait();
            const log1 = (_a = reqReceipt.logs) === null || _a === void 0 ? void 0 : _a[7];
            request = test_helpers_1.oracle.decodeRunRequest(log1);
        });
        describe('before the minimum required time', () => {
            it('does not allow requests to be cancelled', () => test_helpers_1.matchers.evmRevert(rc
                .connect(roles.consumer)
                .cancelRequest(pc.address, request.requestId, request.payment, request.callbackFunc, request.expiration), 'Request is not expired'));
        });
        describe('after the minimum required time', () => {
            beforeEach(async () => {
                await test_helpers_1.helpers.increaseTime5Minutes(provider);
            });
            it('allows the requester to cancel', async () => {
                await rc
                    .connect(roles.consumer)
                    .cancelRequest(pc.address, request.requestId, request.payment, request.callbackFunc, request.expiration);
                const balance = await link.balanceOf(rc.address);
                expect(balance.eq(payment)).toBeTruthy();
            });
            it('does not allow others to call', () => test_helpers_1.matchers.evmRevert(pc
                .connect(roles.stranger)
                .cancelOracleRequest(request.requestId, request.payment, request.callbackFunc, request.expiration), 'Only requester can cancel'));
        });
    });
});
//# sourceMappingURL=PreCoordinator.test.js.map