"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const test_helpers_1 = require("@chainlink/test-helpers");
const cbor_1 = __importDefault(require("cbor"));
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const generated_1 = require("../src/generated");
const coordinatorFactory = new generated_1.CoordinatorFactory();
const meanAggregatorFactory = new generated_1.MeanAggregatorFactory();
const serviceAgreementConsumerFactory = new generated_1.ServiceAgreementConsumerFactory();
const linkTokenFactory = new test_helpers_1.contract.LinkTokenFactory();
// create ethers provider from that web3js instance
const provider = test_helpers_1.setup.provider();
let roles;
beforeAll(async () => {
    const users = await test_helpers_1.setup.users(provider);
    roles = users.roles;
});
describe('ServiceAgreementConsumer', () => {
    const currency = 'USD';
    let link;
    let coord;
    let cc;
    let agreement;
    beforeEach(async () => {
        const meanAggregator = await meanAggregatorFactory
            .connect(roles.defaultAccount)
            .deploy();
        agreement = await test_helpers_1.coordinator.serviceAgreement({
            aggregator: meanAggregator.address,
            oracles: [roles.oracleNode],
        });
        link = await linkTokenFactory.connect(roles.defaultAccount).deploy();
        coord = await coordinatorFactory
            .connect(roles.defaultAccount)
            .deploy(link.address);
        await coord.initiateServiceAgreement(...(await test_helpers_1.coordinator.initiateSAParams(agreement)));
        cc = await serviceAgreementConsumerFactory
            .connect(roles.defaultAccount)
            .deploy(link.address, coord.address, test_helpers_1.coordinator.generateSAID(agreement));
    });
    it('gas price of contract deployment is predictable', async () => {
        var _a, _b, _c;
        const rec = await provider.getTransactionReceipt((_a = cc.deployTransaction.hash, (_a !== null && _a !== void 0 ? _a : '')));
        chai_1.assert.isBelow((_c = (_b = rec.gasUsed) === null || _b === void 0 ? void 0 : _b.toNumber(), (_c !== null && _c !== void 0 ? _c : 0)), 1500000);
    });
    describe('#requestEthereumPrice', () => {
        describe('without LINK', () => {
            it('reverts', async () => {
                await test_helpers_1.matchers.evmRevert(async () => {
                    await cc.requestEthereumPrice(currency);
                });
            });
        });
        describe('with LINK', () => {
            const paymentAmount = test_helpers_1.helpers.toWei('1');
            beforeEach(async () => {
                await link.transfer(cc.address, paymentAmount);
            });
            it('triggers a log event in the Coordinator contract', async () => {
                var _a, _b, _c;
                const tx = await cc.requestEthereumPrice(currency);
                const receipt = await tx.wait();
                const log = (_b = (_a = receipt) === null || _a === void 0 ? void 0 : _a.logs) === null || _b === void 0 ? void 0 : _b[3];
                chai_1.assert.equal((_c = log) === null || _c === void 0 ? void 0 : _c.address.toLowerCase(), coord.address.toLowerCase());
                const request = test_helpers_1.oracle.decodeRunRequest(log);
                chai_1.assert.equal(test_helpers_1.coordinator.generateSAID(agreement), request.specId);
                test_helpers_1.matchers.bigNum(paymentAmount, request.payment);
                chai_1.assert.equal(cc.address.toLowerCase(), request.requester.toLowerCase());
                chai_1.assert.equal(1, request.dataVersion);
                const expected = {
                    path: currency,
                    get: 'https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD,EUR,JPY',
                };
                chai_1.assert.deepEqual(expected, cbor_1.default.decodeFirstSync(request.data));
            });
            it('has a reasonable gas cost', async () => {
                var _a, _b, _c;
                const tx = await cc.requestEthereumPrice(currency);
                const receipt = await tx.wait();
                chai_1.assert.isBelow((_c = (_b = (_a = receipt) === null || _a === void 0 ? void 0 : _a.gasUsed) === null || _b === void 0 ? void 0 : _b.toNumber(), (_c !== null && _c !== void 0 ? _c : -1)), 175000);
            });
        });
        describe('#fulfillOracleRequest', () => {
            const response = ethers_1.ethers.utils.formatBytes32String('1,000,000.00');
            let request;
            beforeEach(async () => {
                var _a, _b, _c;
                await link.transfer(cc.address, test_helpers_1.helpers.toWei('1'));
                const tx = await cc.requestEthereumPrice(currency);
                const receipt = await tx.wait();
                const log = (_b = (_a = receipt) === null || _a === void 0 ? void 0 : _a.logs) === null || _b === void 0 ? void 0 : _b[3];
                chai_1.assert.equal((_c = log) === null || _c === void 0 ? void 0 : _c.address.toLowerCase(), coord.address.toLowerCase());
                request = test_helpers_1.oracle.decodeRunRequest(log);
            });
            it('records the data given to it by the oracle', async () => {
                await coord
                    .connect(roles.oracleNode)
                    .fulfillOracleRequest(request.requestId, response);
                const currentPrice = await cc.currentPrice();
                chai_1.assert.equal(currentPrice, response);
            });
            describe('when the consumer does not recognize the request ID', () => {
                let request2;
                beforeEach(async () => {
                    var _a, _b;
                    // Create a request directly via the oracle, rather than through the
                    // chainlink client (consumer). The client should not respond to
                    // fulfillment of this request, even though the oracle will faithfully
                    // forward the fulfillment to it.
                    const args = test_helpers_1.oracle.encodeOracleRequest(test_helpers_1.coordinator.generateSAID(agreement), cc.address, serviceAgreementConsumerFactory.interface.functions.fulfill.sighash, 48, '0x0');
                    const tx = await link.transferAndCall(coord.address, agreement.payment, args);
                    const receipt = await tx.wait();
                    request2 = test_helpers_1.oracle.decodeRunRequest((_b = (_a = receipt) === null || _a === void 0 ? void 0 : _a.logs) === null || _b === void 0 ? void 0 : _b[2]);
                });
                it('does not accept the data provided', async () => {
                    await coord
                        .connect(roles.oracleNode)
                        .fulfillOracleRequest(request2.requestId, response);
                    const received = await cc.currentPrice();
                    chai_1.assert.equal(ethers_1.ethers.utils.parseBytes32String(received), '');
                });
            });
            describe('when called by anyone other than the oracle contract', () => {
                it('does not accept the data provided', async () => {
                    await test_helpers_1.matchers.evmRevert(async () => {
                        await cc
                            .connect(roles.oracleNode)
                            .fulfill(request.requestId, response);
                    });
                    const received = await cc.currentPrice();
                    chai_1.assert.equal(ethers_1.ethers.utils.parseBytes32String(received), '');
                });
            });
        });
    });
});
//# sourceMappingURL=BasicServiceAgreementConsumer.test.js.map