"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const test_helpers_1 = require("@chainlink/test-helpers");
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const SchnorrSECP256K1Factory_1 = require("../../src/generated/SchnorrSECP256K1Factory");
const f = __importStar(require("./fixtures"));
test_helpers_1.extensions.ethers.BigNumber.extend();
const { bigNumberify: bn } = ethers_1.ethers.utils;
const schnorrSECP256K1Factory = new SchnorrSECP256K1Factory_1.SchnorrSECP256K1Factory();
const provider = test_helpers_1.setup.provider();
let defaultAccount;
beforeAll(async () => {
    const users = await test_helpers_1.setup.users(provider);
    defaultAccount = users.roles.defaultAccount;
});
describe('SchnorrSECP256K1', () => {
    let c;
    const deployment = test_helpers_1.setup.snapshot(provider, async () => {
        c = await schnorrSECP256K1Factory.connect(defaultAccount).deploy();
    });
    beforeEach(async () => {
        await deployment();
    });
    it('Knows a good Schnorr signature from bad', async () => {
        chai_1.assert(f.publicKey[0].lt(f.groupOrder.shrn(1).add(ethers_1.ethers.constants.One)), 'x ordinate of public key must be less than half group order.');
        async function checkSignature(signature) {
            return c.verifySignature(f.publicKey[0], f.pubKeyYParity, signature, f.msgHash, f.kTimesGAddress);
        }
        chai_1.assert(await checkSignature(f.s), 'failed to verify good signature');
        chai_1.assert(!(await checkSignature(f.s.add(ethers_1.ethers.constants.One))), // Corrupt signature for
        'failed to reject bad signature');
        const gasUsed = await c.estimate.verifySignature(f.publicKey[0], f.pubKeyYParity, f.s, f.msgHash, f.kTimesGAddress);
        chai_1.assert.isBelow(gasUsed.toNumber(), 37500, 'burns too much gas');
    });
    it('Accepts the signatures generated on the go side', async () => {
        var _a;
        f.tests.push(f.dssTest);
        for (let i = 0; i < Math.min(1, f.tests.length); i++) {
            const numbers = f.tests[i].slice(0, f.tests[i].length - 1);
            const [msgHash, , pX, pY, sig] = numbers.map(test_helpers_1.helpers.addHexPrefix).map(bn);
            const rEIP55Address = ethers_1.ethers.utils.getAddress((_a = f.tests[i].pop(), (_a !== null && _a !== void 0 ? _a : '')));
            chai_1.assert(await c.verifySignature(pX, pY.isEven() ? 0 : 1, sig, msgHash, rEIP55Address), 'failed to verify signature constructed by golang tests');
            chai_1.assert(!(await c.verifySignature(pX, pY.isEven() ? 0 : 1, sig.add(ethers_1.ethers.constants.One), msgHash, rEIP55Address)), 'failed to reject bad signature');
        }
    });
});
//# sourceMappingURL=Schnorr.test.js.map