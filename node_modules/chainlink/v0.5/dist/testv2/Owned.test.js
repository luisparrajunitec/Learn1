"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const test_helpers_1 = require("@chainlink/test-helpers");
const chai_1 = require("chai");
const generated_1 = require("../src/generated");
const ownedTestHelperFactory = new generated_1.OwnedTestHelperFactory();
const provider = test_helpers_1.setup.provider();
let personas;
let owner;
let nonOwner;
let newOwner;
beforeAll(async () => {
    const users = await test_helpers_1.setup.users(provider);
    personas = users.personas;
    owner = personas.Carol;
    nonOwner = personas.Neil;
    newOwner = personas.Ned;
});
describe('Owned', () => {
    let owned;
    const ownedEvents = ownedTestHelperFactory.interface.events;
    beforeEach(async () => {
        owned = await ownedTestHelperFactory.connect(owner).deploy();
    });
    it('has a limited public interface', () => {
        test_helpers_1.matchers.publicAbi(ownedTestHelperFactory, [
            'acceptOwnership',
            'owner',
            'transferOwnership',
            // test helper public methods
            'modifierOnlyOwner',
        ]);
    });
    describe('#constructor', () => {
        it('assigns ownership to the deployer', async () => {
            const [actual, expected] = await Promise.all([
                owner.getAddress(),
                owned.owner(),
            ]);
            chai_1.assert.equal(actual, expected);
        });
    });
    describe('#onlyOwner modifier', () => {
        describe('when called by an owner', () => {
            it('successfully calls the method', async () => {
                const tx = await owned.connect(owner).modifierOnlyOwner();
                const receipt = await tx.wait();
                expect(test_helpers_1.helpers.findEventIn(receipt, ownedEvents.Here)).toBeDefined();
            });
        });
        describe('when called by anyone but the owner', () => {
            it('reverts', () => test_helpers_1.matchers.evmRevert(owned.connect(nonOwner).modifierOnlyOwner()));
        });
    });
    describe('#transferOwnership', () => {
        describe('when called by an owner', () => {
            it('emits a log', async () => {
                const tx = await owned
                    .connect(owner)
                    .transferOwnership(newOwner.address);
                const receipt = await tx.wait();
                const event = test_helpers_1.helpers.findEventIn(receipt, ownedEvents.OwnershipTransferRequested);
                expect(test_helpers_1.helpers.eventArgs(event).to).toEqual(newOwner.address);
                expect(test_helpers_1.helpers.eventArgs(event).from).toEqual(owner.address);
            });
        });
    });
    describe('when called by anyone but the owner', () => {
        it('successfully calls the method', () => test_helpers_1.matchers.evmRevert(owned.connect(nonOwner).transferOwnership(newOwner.address)));
    });
    describe('#acceptOwnership', () => {
        describe('after #transferOwnership has been called', () => {
            beforeEach(async () => {
                await owned.connect(owner).transferOwnership(newOwner.address);
            });
            it('allows the recipient to call it', async () => {
                const tx = await owned.connect(newOwner).acceptOwnership();
                const receipt = await tx.wait();
                const event = test_helpers_1.helpers.findEventIn(receipt, ownedEvents.OwnershipTransfered);
                expect(test_helpers_1.helpers.eventArgs(event).to).toEqual(newOwner.address);
                expect(test_helpers_1.helpers.eventArgs(event).from).toEqual(owner.address);
            });
            it('does not allow a non-recipient to call it', () => test_helpers_1.matchers.evmRevert(owned.connect(nonOwner).acceptOwnership()));
        });
    });
});
//# sourceMappingURL=Owned.test.js.map