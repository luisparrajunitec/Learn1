/// <reference types="node" />
import { ethers } from 'ethers';
import { Oracle } from './generated/Oracle';
import { TypedEventDescription } from './generated';
import { LinkToken } from './generated/LinkToken';
import { ContractReceipt } from 'ethers/contract';
export declare const utils: typeof import("ethers/utils");
export interface Roles {
    defaultAccount: ethers.Wallet;
    oracleNode: ethers.Wallet;
    oracleNode1: ethers.Wallet;
    oracleNode2: ethers.Wallet;
    oracleNode3: ethers.Wallet;
    oracleNode4: ethers.Wallet;
    stranger: ethers.Wallet;
    consumer: ethers.Wallet;
}
export interface Personas {
    Default: ethers.Wallet;
    Neil: ethers.Wallet;
    Ned: ethers.Wallet;
    Nelly: ethers.Wallet;
    Carol: ethers.Wallet;
    Eddy: ethers.Wallet;
}
interface RolesAndPersonas {
    roles: Roles;
    personas: Personas;
}
export interface ServiceAgreement {
    payment: ethers.utils.BigNumberish;
    expiration: ethers.utils.BigNumberish;
    endAt: ethers.utils.BigNumberish;
    oracles: string[];
    requestDigest: string;
    aggregator: string;
    aggInitiateJobSelector: string;
    aggFulfillSelector: string;
}
export interface OracleSignature {
    vs: ethers.utils.BigNumberish[];
    rs: string[];
    ss: string[];
}
/**
 * This helper function allows us to make use of ganache snapshots,
 * which allows us to snapshot one state instance and revert back to it.
 *
 * This is used to memoize expensive setup calls typically found in beforeEach hooks when we
 * need to setup our state with contract deployments before running assertions.
 *
 * @param provider The provider that's used within the tests
 * @param cb The callback to execute that generates the state we want to snapshot
 */
export declare function useSnapshot(provider: ethers.providers.JsonRpcProvider, cb: () => Promise<void>): () => Promise<void>;
/**
 * A wrapper function to make generated contracts compatible with truffle test suites.
 *
 * Note that the returned contract is an instance of ethers.Contract, not a @truffle/contract, so there are slight
 * api differences, though largely the same.
 *
 * @see https://docs.ethers.io/ethers.js/html/api-contract.html
 * @param contractFactory The ethers based contract factory to interop with
 * @param address The address to supply as the signer
 */
export declare function create<T extends new (...args: any[]) => any>(contractFactory: T, address: string): InstanceType<T>;
/**
 * Generate roles and personas for tests along with their corrolated account addresses
 */
export declare function initializeRolesAndPersonas(provider: ethers.providers.JsonRpcProvider): Promise<RolesAndPersonas>;
/**
 * Parse out an evm word (32 bytes) into an address (20 bytes) representation
 * @param hex The evm word in hex string format to parse the address
 * out of.
 */
export declare function evmWordToAddress(hex?: string): string;
export declare function assertActionThrows(action: (() => Promise<any>) | Promise<any>, msg?: string): Promise<void>;
export declare function checkPublicABI(contract: ethers.Contract | ethers.ContractFactory, expectedPublic: string[]): void;
/**
 * Convert a value to a hex string
 * @param args Value to convert to a hex string
 */
export declare function toHex(...args: Parameters<typeof utils.hexlify>): ReturnType<typeof utils.hexlify>;
/**
 * Convert an Ether value to a wei amount
 * @param args Ether value to convert to an Ether amount
 */
export declare function toWei(...args: Parameters<typeof utils.parseEther>): ReturnType<typeof utils.parseEther>;
export declare function decodeRunRequest(log?: ethers.providers.Log): RunRequest;
/**
 * Decode a log into a run
 * @param log The log to decode
 * @todo Do we really need this?
 */
export declare function decodeRunABI(log: ethers.providers.Log): [string, string, string, string];
/**
 * Decodes a CBOR hex string, and adds opening and closing brackets to the CBOR if they are not present.
 *
 * @param hexstr The hex string to decode
 */
export declare function decodeDietCBOR(hexstr: string): any;
export interface RunRequest {
    callbackAddr: string;
    callbackFunc: string;
    data: Buffer;
    dataVersion: number;
    expiration: string;
    id: string;
    jobId: string;
    payment: string;
    requester: string;
    topic: string;
}
/**
 * Add a hex prefix to a hex string
 * @param hex The hex string to prepend the hex prefix to
 */
export declare function addHexPrefix(hex: string): string;
export declare function stripHexPrefix(hex: string): string;
/**
 * Convert a number value to bytes32 format
 *
 * @param num The number value to convert to bytes32 format
 */
export declare function numToBytes32(num: Parameters<typeof ethers.utils.hexlify>[0]): string;
export declare function toUtf8(...args: Parameters<typeof ethers.utils.toUtf8Bytes>): ReturnType<typeof ethers.utils.toUtf8Bytes>;
/**
 * Compute the keccak256 cryptographic hash of a value, returned as a hex string.
 * (Note: often Ethereum documentation refers to this, incorrectly, as SHA3)
 * @param args The data to compute the keccak256 hash of
 */
export declare function keccak(...args: Parameters<typeof ethers.utils.keccak256>): ReturnType<typeof ethers.utils.keccak256>;
declare type TxOptions = Omit<ethers.providers.TransactionRequest, 'to' | 'from'>;
export declare function fulfillOracleRequest(oracleContract: Oracle, runRequest: RunRequest, response: string, options?: TxOptions): ReturnType<typeof oracleContract.fulfillOracleRequest>;
export declare function cancelOracleRequest(oracleContract: Oracle, request: RunRequest, options?: TxOptions): ReturnType<typeof oracleContract.cancelOracleRequest>;
export declare function requestDataBytes(specId: string, to: string, fHash: string, nonce: number, dataBytes: string): string;
interface Callable {
    address: string;
}
export declare function requestDataFrom(callable: Callable, link: LinkToken, amount: ethers.utils.BigNumberish, args: string, options?: Omit<ethers.providers.TransactionRequest, 'to' | 'from'>): ReturnType<typeof link.transferAndCall>;
/**
 * Increase the current time within the evm to "n" seconds past the current time
 * @param seconds The number of seconds to increase to the current time by
 * @param provider The ethers provider to send the time increase request to
 */
export declare function increaseTimeBy(seconds: number, provider: ethers.providers.JsonRpcProvider): Promise<void>;
/**
 * Increase the current time within the evm to 5 minutes past the current time
 *
 * @param provider The ethers provider to send the time increase request to
 */
export declare function increaseTime5Minutes(provider: ethers.providers.JsonRpcProvider): Promise<void>;
/**
 * Convert a buffer to a hex string
 * @param hexstr The hex string to convert to a buffer
 */
export declare function hexToBuf(hexstr: string): Buffer;
declare type Hash = ReturnType<typeof ethers.utils.keccak256>;
export declare function encodeServiceAgreement(sa: ServiceAgreement): string;
export declare function encodeOracleSignatures(os: OracleSignature): string;
export declare function computeOracleSignature(agreement: ServiceAgreement, oracle: ethers.Wallet): Promise<OracleSignature>;
/**
 * Digest of the ServiceAgreement.
 */
export declare function generateSAID(sa: ServiceAgreement): Hash;
/**
 * Turn a [x,y] coordinate into an ethereum address
 * @param pubkey The x,y coordinate to turn into an ethereum address
 */
export declare function pubkeyToAddress(pubkey: ethers.utils.BigNumber[]): string;
interface EventArgsArray extends Array<any> {
    [key: string]: any;
}
/**
 * Typecast an ethers event to its proper type, until
 * https://github.com/ethers-io/ethers.js/pull/698 is addressed
 *
 * @param event The event to typecast
 */
export declare function eventArgs(event?: ethers.Event): EventArgsArray;
/**
 * Find an event within a transaction receipt by its event description
 *
 * @param receipt The events array to search through
 * @param eventDescription The event description to pass to check its name by
 */
export declare function findEventIn(receipt: ContractReceipt, eventDescription: TypedEventDescription<any>): ethers.Event | undefined;
/**
 * Calculate six months from the current date in seconds
 */
export declare function sixMonthsFromNow(): ethers.utils.BigNumber;
export {};
